WEBVTT

1
00:00:00.210 --> 00:00:03.240
以前のビデオでは、
私はその放送を述べました

2
00:00:03.240 --> 00:00:07.040
あなたが使用できる別の技術であります
あなたのPythonコードの実行を高速化します。

3
00:00:07.040 --> 00:00:11.860
このビデオでは、のは、どのように掘り下げてみましょう
Pythonでの放送が実際に動作します。

4
00:00:11.860 --> 00:00:14.240
今日は仮定しよう
例で放送。

5
00:00:14.240 --> 00:00:18.730
この行列では、私は数を示してきました
炭水化物からのカロリー、

6
00:00:18.730 --> 00:00:22.320
タンパク質、および
四つの異なる食品の100グラム中の脂肪。

7
00:00:22.320 --> 00:00:25.380
ですから、例えば、
リンゴの100グラムが判明し、

8
00:00:25.380 --> 00:00:29.690
炭水化物からの56カロリーを持っており、
タンパク質や脂肪からはるかに少ないです。

9
00:00:29.690 --> 00:00:35.110
対照的に、100グラムの、一方
牛肉は、タンパク質から104カロリーを持っており、

10
00:00:35.110 --> 00:00:37.620
脂肪から135カロリー。

11
00:00:37.620 --> 00:00:43.330
それでは、あなたの目標はにあるとしましょう
カロリーの割合を計算

12
00:00:43.330 --> 00:00:48.440
炭水化物、タンパク質からと
4つの食品のそれぞれの脂肪。

13
00:00:48.440 --> 00:00:52.338
したがって、たとえば、
あなたがこのコラムを見ればと

14
00:00:52.338 --> 00:00:57.697
その列の数字を足し
あなたはリンゴの100グラムを得ます

15
00:00:57.697 --> 00:01:02.580
その56プラス1.2プラス1.8を持っています
それは59カロリーです。

16
00:01:02.580 --> 00:01:06.806
そして、その割合のパーセンテージとして

17
00:01:06.806 --> 00:01:11.800
炭水化物からのカロリー
リンゴの場合と

18
00:01:11.800 --> 00:01:16.932
59オーバー56も、それはおよそ94.9パーセントです。

19
00:01:16.932 --> 00:01:22.399
リンゴのカロリーの最もので、
対照的に、一方で、炭水化物から来ます、

20
00:01:22.399 --> 00:01:27.630
牛肉のカロリーのほとんどが来ます
タンパク質や脂肪からのように。

21
00:01:27.630 --> 00:01:33.630
だから、あなたが欲しい計算が実際にあります
4つの列のそれぞれを総括します

22
00:01:33.630 --> 00:01:38.740
この行列の合計数を取得します
リンゴの100グラムでカロリーの、

23
00:01:38.740 --> 00:01:40.920
牛肉、卵、ジャガイモ。

24
00:01:40.920 --> 00:01:45.090
そして、マトリックス全体に分割します

25
00:01:47.230 --> 00:01:51.230
の割合（％）を取得するように、
炭水化物、タンパク質からのカロリーと

26
00:01:51.230 --> 00:01:54.870
4つの食品のそれぞれの脂肪。

27
00:01:54.870 --> 00:02:01.370
そこで問題は、あなたが行うことができ、あります
明示的なforループのないこの？

28
00:02:01.370 --> 00:02:03.290
のは、見てみましょう
どのようにあなたはそれを行うことができます。

29
00:02:04.450 --> 00:02:08.602
私は何をするつもりはあります
あなたが設定することができる方法をお見せし、

30
00:02:08.602 --> 00:02:12.990
この行列に等しいと言います
4つの行列Aによって3

31
00:02:12.990 --> 00:02:18.300
そして、Pythonコードの1行を持ちます
私たちは列を下に合計するつもりです。

32
00:02:18.300 --> 00:02:22.078
だから我々は4つの数字を取得するつもりです
総数に対応

33
00:02:22.078 --> 00:02:25.046
これらの4人にカロリーの
食品のさまざまな種類、

34
00:02:25.046 --> 00:02:28.095
これら四つの100グラム
食品の様々なタイプ。

35
00:02:28.095 --> 00:02:32.113
そして、私は2番目のラインを使用するつもりです
のそれぞれを分割するPythonコードの

36
00:02:32.113 --> 00:02:35.390
4つの列によって
それに対応する合計。

37
00:02:35.390 --> 00:02:37.250
その口頭で説明する場合
非常に明確ではなかったです、

38
00:02:37.250 --> 00:02:40.670
うまくいけば、それは、第二に鮮明になります
私たちは、Pythonコードで見たとき。

39
00:02:40.670 --> 00:02:42.460
そこでここでは、木星のノートブックです。

40
00:02:42.460 --> 00:02:46.150
私はすでに最初にこれを書いています
事前移入へのコードの一部

41
00:02:46.150 --> 00:02:49.860
私たちが持っていた番号の行列A
ちょうど今、私たちは、入力したシフトを打つだろうと

42
00:02:49.860 --> 00:02:51.220
まさにそれを実行し、その行列Aがあります

43
00:02:51.220 --> 00:02:55.080
そして今、ここに2つです
Pythonコードの行。

44
00:02:55.080 --> 00:02:59.983
まず、我々は計算するつもりです
タウは、その合計に等しいです。

45
00:02:59.983 --> 00:03:02.280
そしてXは、垂直合計する0手段に等しいです。

46
00:03:02.280 --> 00:03:05.280
私たちは少しのそれについての詳細を言いますよ。

47
00:03:05.280 --> 00:03:06.076
そして、校正印刷します。

48
00:03:06.076 --> 00:03:07.825
だから我々は、垂直方向に合計ます。

49
00:03:07.825 --> 00:03:13.735
今59は、数の合計です
アップルではカロリー、239でした

50
00:03:13.735 --> 00:03:19.575
牛肉カロリーの合計数
ように、卵とジャガイモと。

51
00:03:19.575 --> 00:03:25.151
そして、計算割合が

52
00:03:25.151 --> 00:03:30.733
A / cal.reshape 1,4に等しいです。

53
00:03:30.733 --> 00:03:33.927
実は、私たちは割合にしたいです、
ので、ここで100を掛け。

54
00:03:35.913 --> 00:03:38.860
そしてのは割合を印刷してみましょう。

55
00:03:40.800 --> 00:03:41.950
さんがそれを実行してみましょう。

56
00:03:41.950 --> 00:03:46.870
など
私たちが行列Aを撮影したそのコマンドと

57
00:03:46.870 --> 00:03:50.820
4つの行列で、このいずれかでそれを割りました。

58
00:03:50.820 --> 00:03:52.672
そして、これは私たちを与えます
パーセンテージのマトリックス。

59
00:03:52.672 --> 00:03:57.327
我々はによって種類のうち働いたように
そこにリンゴでちょうど今、手

60
00:03:57.327 --> 00:04:02.480
最初の列94.9パーセントでした
カロリーは炭水化物からです。

61
00:04:02.480 --> 00:04:04.000
のは、スライドに戻りましょう。

62
00:04:04.000 --> 00:04:06.310
だから2を繰り返します
私たちが持っていたコードの行、

63
00:04:06.310 --> 00:04:09.940
これは書かれているものです
木星のノートブックでアウト。

64
00:04:09.940 --> 00:04:13.306
詳細は、このパラメータのビットを追加するには、

65
00:04:13.306 --> 00:04:18.540
（軸= 0）、あなたがいることを意味します
Pythonは縦に合計します。

66
00:04:18.540 --> 00:04:21.567
だから、これは軸0このある場合
縦に合計することを意味し、

67
00:04:21.567 --> 00:04:24.029
横軸は、軸1であるように。

68
00:04:24.029 --> 00:04:28.050
だから、1軸または総和を書くことができます
水平方向の代わりに和の垂直。

69
00:04:28.050 --> 00:04:30.670
そして、ここでは、このコマンドを、

70
00:04:30.670 --> 00:04:35.210
これは、Pythonの例であります
あなたは行列Aを取る放送

71
00:04:35.210 --> 00:04:43.330
だから、これは3〜4の行列で、
次の4つの行列ずつで割り。

72
00:04:43.330 --> 00:04:47.370
そして技術的には、この後の最初の
CALコードの行は、変数CAL、

73
00:04:47.370 --> 00:04:49.590
すでに4つの行列ずつです。

74
00:04:49.590 --> 00:04:52.616
だから、技術的に、あなたは必要ありません。
コールするので、ここで再び再構築

75
00:04:52.616 --> 00:04:54.722
それは実際には少し冗長です。

76
00:04:54.722 --> 00:04:59.140
しかし、私は場合は、Pythonのコードを書いているとき、
私は、どのような行列全くわからないんだけど

77
00:04:59.140 --> 00:05:04.056
私は、多くの場合、行列の次元かどうか
ただ単にに再形成コマンドを呼び出します

78
00:05:04.056 --> 00:05:07.833
それが正しいということを確認してください
列ベクトル又は行ベクトルまたは

79
00:05:07.833 --> 00:05:09.500
あなたはそれになりたいものは何でも。

80
00:05:09.500 --> 00:05:11.840
リシェイプコマンドは、一定の時間です。

81
00:05:11.840 --> 00:05:15.150
これは、順番1つの操作です
それは呼び出すことは非常に安いです。

82
00:05:15.150 --> 00:05:18.404
だから、リシェイプの使用について恥ずかしがらないでください
ことを確認するためにコマンドをお使いの行列

83
00:05:18.404 --> 00:05:20.830
あなたはそれをする必要がサイズがあります。

84
00:05:21.920 --> 00:05:27.272
それでは、どのように詳細に説明しましょう
このタイプの操作は右、動作しますか？

85
00:05:27.272 --> 00:05:33.780
私たちは、3〜4の行列を有しており、
我々は4つの行列により1を割りました。

86
00:05:33.780 --> 00:05:37.840
だから、どのように次の3つによると分けることができます
4つの行列により1 4つの行列？

87
00:05:37.840 --> 00:05:38.860
または4つのベクトルによって1？

88
00:05:40.130 --> 00:05:43.160
さんは、さらにいくつか見ていきましょう
放送の例。

89
00:05:43.160 --> 00:05:47.920
あなたが4によって1ベクトルを取る場合と、
数に追加し、どのような

90
00:05:47.920 --> 00:05:53.011
Pythonは行います。この番号を取るし、
自動拡張

91
00:05:53.011 --> 00:05:58.180
同様に4一つのベクトルにそれ、
次のように。

92
00:05:58.180 --> 00:06:00.257
そのためベクトル[1、2、3、

93
00:06:00.257 --> 00:06:04.450
4]プラス番号100は終わります
右側にそのベクトルを持ちます。

94
00:06:04.450 --> 00:06:09.280
あなたは、すべての要素に100を追加しています
実際に、私たちは、このフォームを使用します

95
00:06:09.280 --> 00:06:14.365
その定数だった放送
以前のビデオでパラメータb。

96
00:06:14.365 --> 00:06:19.414
そして、放送のこのタイプで動作します
列ベクトルと行ベクトルの両方、

97
00:06:19.414 --> 00:06:24.157
実際に、私たちは、同様の形式を使用します
定数と以前の放送

98
00:06:24.157 --> 00:06:29.330
我々は、ベクトルであることに追加しています
ロジスティック回帰におけるパラメータb。

99
00:06:29.330 --> 00:06:31.610
ここで別の例です。

100
00:06:31.610 --> 00:06:35.900
あなたは2を持っているとしましょう
3つの行列によると、

101
00:06:35.900 --> 00:06:39.420
あなたはnの行列で、この1にそれを追加します。

102
00:06:40.950 --> 00:06:45.682
もしあれば一般的なケースのようになります

103
00:06:45.682 --> 00:06:50.583
ここでいくつかの（M、N）のマトリックスを有し、

104
00:06:50.583 --> 00:06:55.330
あなたは（1、n）の行列に追加します。

105
00:06:55.330 --> 00:06:58.667
行列mをコピー何Pythonは行いますです、

106
00:06:58.667 --> 00:07:03.672
時間は、m行n列のマトリックスにこれをオンにします
その代わりに、この一つ

107
00:07:03.672 --> 00:07:09.980
それはそれを二度コピーします3つの行列
この例では、この中にそれを入れてください。

108
00:07:09.980 --> 00:07:14.092
また、2〜3の行列と
我々はので、これらを追加します

109
00:07:14.092 --> 00:07:18.270
あなたは、右側の合計になってしまいます
はい？

110
00:07:18.270 --> 00:07:21.583
だからあなたが撮影しました、
あなたは、最初の列に100を追加しました

111
00:07:21.583 --> 00:07:25.812
第二カラムに200を加え、
第3列300を追加しました。

112
00:07:25.812 --> 00:07:28.796
そして、これは基本的に私たちです
前のスライドの上にいました、

113
00:07:28.796 --> 00:07:32.810
我々は除算演算を使用することを除いて、
代わりに、加算演算の。

114
00:07:34.180 --> 00:07:40.402
だから、最後の一例として、
あなたは（m、n）が行列を持っているかどうか、および

115
00:07:40.402 --> 00:07:46.260
あなたは、（M、1）ベクトルにこれを追加します
（M、1）マトリックス。

116
00:07:47.310 --> 00:07:50.760
それからちょうど水平に、このn回コピーします。

117
00:07:50.760 --> 00:07:53.510
だから、（M、N）行列で終わります。

118
00:07:53.510 --> 00:07:56.990
あなたがコピー想像できるように、
それは、水平方向に3回。

119
00:07:56.990 --> 00:07:58.650
そして、あなたはそれらを追加します。

120
00:07:58.650 --> 00:08:01.070
あなたがそれらを追加するときに、あなたはこれで終わります。

121
00:08:01.070 --> 00:08:06.890
だから我々は、最初の行に100を追加しましたし、
第二行に200を追加しました。

122
00:08:08.270 --> 00:08:12.061
ここではより一般的な原則です
Pythonで放送。

123
00:08:12.061 --> 00:08:17.353
あなたは（m、n）が行列を持っていて、追加した場合や

124
00:08:17.353 --> 00:08:24.409
減算または乗算か
（1、n）の行列で割ます、

125
00:08:24.409 --> 00:08:31.177
これは、nそれをコピーします
（M、N）行列に時間。

126
00:08:31.177 --> 00:08:33.781
そして、追加を適用し、
減算、

127
00:08:33.781 --> 00:08:36.140
賢明な分割要素の掛け算。

128
00:08:37.250 --> 00:08:42.250
逆の場合は、（M、N）を取ることでした
マトリックスと、加算、減算、乗算、

129
00:08:42.250 --> 00:08:49.060
除算（M、1）マトリックス
そしてまた、これは今をn回、それをコピーします。

130
00:08:49.060 --> 00:08:54.740
及び（M、N）行列にそれを回すと
その後、賢明な操作要素を適用します。

131
00:08:54.740 --> 00:09:00.327
ただ、放送の1、
これはあなたが持っている場合（Mを、1）行列であり、

132
00:09:00.327 --> 00:09:05.175
そのためには、実際の列ベクトルです
[1,2,3]のように、あなたは、追加します

133
00:09:05.175 --> 00:09:08.482
減算、乗算または
行数で割ます。

134
00:09:08.482 --> 00:09:11.080
そのため、おそらく（1,1）行列。

135
00:09:11.080 --> 00:09:16.117
だから、その結果としてプラス100、
あなたはコピーし終わります

136
00:09:16.117 --> 00:09:23.512
この実数n回あなたがよまで
また、別の（N、1）マトリックスを得ます。

137
00:09:23.512 --> 00:09:29.700
そして、あなたは操作などを行います
この例では、要素単位での追加など。

138
00:09:29.700 --> 00:09:35.823
そして、似たようなものために働きます
行ベクトル。

139
00:09:38.281 --> 00:09:43.730
放送の完全一般的なバージョン
これより少しでも多くを行うことができます。

140
00:09:43.730 --> 00:09:49.080
あなたが興味を持っている場合のことができます
マニュアルを読んで

141
00:09:49.080 --> 00:09:52.240
numpyの、放送を見て
そのドキュメントインチ

142
00:09:52.240 --> 00:09:56.380
これは、少しでも多くを提供します
放送の一般的な定義。

143
00:09:56.380 --> 00:10:00.140
しかし、スライド上のものがメインです
あなたが終わる放送のフォーム

144
00:10:00.140 --> 00:10:02.560
するときに使用する必要
ニューラルネットワークを実装します。

145
00:10:03.890 --> 00:10:06.840
私たちが包む前に、
以下のためであるだけで1最後のコメント、

146
00:10:06.840 --> 00:10:10.210
に使用されているあなたのそれら
いずれかのMATLABでのプログラミングや

147
00:10:10.210 --> 00:10:15.760
オクターブ、あなたはMATLABを使用した場合や
オクターブ機能bsxfun

148
00:10:15.760 --> 00:10:20.590
ニューラルネットワークにおけるプログラミングbsxfunはありません
似たような、全く同じではありません。

149
00:10:20.590 --> 00:10:25.750
しかし、それは多くの場合、同様の目的のために使用されています
我々はPythonで放送を使用しているものなど。

150
00:10:25.750 --> 00:10:28.505
しかし、これはのみのために実際にあります
非常に高度なMATLABと

151
00:10:28.505 --> 00:10:31.600
オクターブのユーザー、あなたがこののことを聞いていませんでした場合は、
ご心配なく。

152
00:10:31.600 --> 00:10:35.524
あなたがいるときにそれを知っている必要はありません。
Pythonでニューラルネットワークをコーディング。

153
00:10:35.524 --> 00:10:38.720
だから、それはPythonで放送していました。

154
00:10:38.720 --> 00:10:42.360
私はあなたがプログラミングを行うときにことを願っています
放送はあなたをできるようになります宿題

155
00:10:42.360 --> 00:10:44.580
高速なコードの実行をしないようにだけ、

156
00:10:44.580 --> 00:10:48.920
だけでなく、あなたが欲しいものを得るのを助けます
少ないコード行で行います。

157
00:10:50.360 --> 00:10:53.630
あなたはプログラミングに飛び込む前に、
運動し、私はあなたと共有したいです

158
00:10:53.630 --> 00:10:56.290
アイデアの1つの以上のセット、
これは、いくつかのヒントがあることで、

159
00:10:56.290 --> 00:11:00.700
私が見つけたトリックが減少します
私のPythonコードのバグの数と、

160
00:11:00.700 --> 00:11:02.640
私はあまりにもあなたを助けることを願っています。

161
00:11:02.640 --> 00:11:05.550
それとので、
のは、次のビデオでそのことについてお話ししましょう。
