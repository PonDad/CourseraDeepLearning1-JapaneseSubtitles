WEBVTT

1
00:00:00.000 --> 00:00:01.440
以前のビデオでは、

2
00:00:01.440 --> 00:00:05.700
あなたが彼らの予測を計算するためにベクトル化を使用することができる方法を説明しました。

3
00:00:05.700 --> 00:00:11.485
小文字は、同時に全体のトレーニングセットOのためです。

4
00:00:11.485 --> 00:00:15.030
このビデオでは、あなたはまたにベクトル化を使用する方法をご覧ください

5
00:00:15.030 --> 00:00:19.205
すべてのMの訓練サンプルの勾配の計算を行います。

6
00:00:19.205 --> 00:00:21.380
ここでも、同時にすべての一種。

7
00:00:21.380 --> 00:00:22.890
そして、このビデオの最後に、

8
00:00:22.890 --> 00:00:26.175
我々はそれをすべて一緒に入れて、あなたが得ることができますどのように表示されます

9
00:00:26.175 --> 00:00:29.730
ロジスティック回帰の非常に効率的な実装。

10
00:00:29.730 --> 00:00:32.505
だから、あなたは、勾配計算のためにそれを覚えているかもしれ

11
00:00:32.505 --> 00:00:36.910
私たちがやったことは、我々が最初に例えばDZ1を計算し、

12
00:00:36.910 --> 00:00:43.870
A1マイナスY1なり、その後、DZ2イコール可能性があります

13
00:00:43.870 --> 00:00:52.134
A2マイナスY2のように。

14
00:00:52.134 --> 00:00:56.425
そして、その上のすべてのMの訓練例のため。

15
00:00:56.425 --> 00:01:01.218
だから、私たちがやろうとしていることは、新たな変数を定義しています、

16
00:01:01.218 --> 00:01:08.595
dzがDZ1、DZ2、DZMになるだろう。

17
00:01:08.595 --> 00:01:13.910
再び、すべてのD小文字Z変数は水平に積み重ね。

18
00:01:13.910 --> 00:01:21.200
だから、これは、M行列、または代替的に、M次元の列ベクトルが1であろう。

19
00:01:21.200 --> 00:01:23.520
今思い出すその前のスライドから、

20
00:01:23.520 --> 00:01:28.405
我々はすでに、このだった資本Aを計算する方法を考え出したい：a1から

21
00:01:28.405 --> 00:01:36.735
午前と私たちはYMを通じてY1として資本Yを見つけなければなりませんでした。

22
00:01:36.735 --> 00:01:39.200
また、あなたは水平に積み重ねられた、知っています。

23
00:01:39.200 --> 00:01:42.780
だから、これらの定義に基づいて、

24
00:01:42.780 --> 00:01:46.770
多分あなたはDZのように計算することができることを自分で見ることができます

25
00:01:46.770 --> 00:01:52.750
Y1  -  A1と同じであることを行っているためだけでマイナスY。

26
00:01:52.750 --> 00:01:55.670
だから、最初の要素、A2  -  Y2、

27
00:01:55.670 --> 00:01:59.980
第二の要素でというようにそう。

28
00:01:59.980 --> 00:02:06.115
そして、この第1の要素A1ので -  y1が正確にDZ1の定義です。

29
00:02:06.115 --> 00:02:11.670
2番目の要素は、正確に定義DZ2のとそうです。

30
00:02:11.670 --> 00:02:13.965
だから、コードは1行だけで、

31
00:02:13.965 --> 00:02:20.095
あなたは、同時にこのすべてを計算することができます。

32
00:02:20.095 --> 00:02:24.010
さて、以前の実装では、

33
00:02:24.010 --> 00:02:27.695
我々はすでに1つのフルループの解消を得ているが、我々はまだ持っていました

34
00:02:27.695 --> 00:02:31.600
20例に対するこの第二の完全ループ。

35
00:02:31.600 --> 00:02:35.440
だから我々はゼロのベクトルにゼロにDWを初期化します。

36
00:02:35.440 --> 00:02:38.905
しかし、我々はまだ我々が持っている20例をループする必要があります

37
00:02:38.905 --> 00:02:43.015
、DWプラス×1回DZ1に等しいです。

38
00:02:43.015 --> 00:02:50.440
最初のトレーニング例えばDWプラスように×2 DZ2に等しいと。

39
00:02:50.440 --> 00:02:56.980
だから我々は、M回行い、その後、DW除算は、右、Bについても同様にMで等しいと？

40
00:02:56.980 --> 00:03:03.370
デシベル0に初期化し、デシベルプラスDZ1に等しいました。

41
00:03:03.370 --> 00:03:09.120
デシベルプラスあなたが知っているまでDZ2等しいです

42
00:03:09.120 --> 00:03:16.835
DZ（M）とDB格差はM.だからそれは我々が以前の実装で持っていたものです等しいです。

43
00:03:16.835 --> 00:03:18.700
我々はすでに1つのフルループを処分したと思います。

44
00:03:18.700 --> 00:03:25.045
だから、少なくとも今DWはベクトルであり、我々は別途DW1を更新行きました、

45
00:03:25.045 --> 00:03:26.850
その上DW2と。

46
00:03:26.850 --> 00:03:29.860
そこで、我々はすでに処分したが、それでも我々

47
00:03:29.860 --> 00:03:33.630
トレーニングセットにおけるMの例を完全にループを持っていました。

48
00:03:33.630 --> 00:03:36.290
それでは、これらの操作を取り、それらをベクトル化しましょう。

49
00:03:36.290 --> 00:03:38.380
ここで我々は、何ができるかです

50
00:03:38.380 --> 00:03:42.745
デシベルのベクトル化の実装では、基本的には、合算されていました

51
00:03:42.745 --> 00:03:47.940
これらDZSの全て、次にMで割ます。そう、

52
00:03:47.940 --> 00:03:51.580
DBは、基本的にM分の1であります

53
00:03:51.580 --> 00:03:56.530
私からの合計がDZIのメートルを通じて一度に等しく、

54
00:03:56.530 --> 00:04:03.055
ウェル全てDZSは、その行ベクトルおよびSO Pythonであります

55
00:04:03.055 --> 00:04:04.765
何をやっていることは、あなたが知って実装され、

56
00:04:04.765 --> 00:04:08.155
m回のNP上1。

57
00:04:08.155 --> 00:04:12.210
Zの合計。

58
00:04:12.210 --> 00:04:15.115
だから、あなたはちょうどこの変数を取り、NPを呼び出します。

59
00:04:15.115 --> 00:04:19.195
和その上機能とそれはあなたのデシベルを与えるだろう。

60
00:04:19.195 --> 00:04:22.330
どの程度DWまたは単に書きます

61
00:04:22.330 --> 00:04:26.375
確認することができ、正しい方程式から行うには正しいことです。

62
00:04:26.375 --> 00:04:28.164
DWはM上の1つであることが判明し、

63
00:04:28.164 --> 00:04:34.485
時代行列X回のDZ転置。

64
00:04:34.485 --> 00:04:37.990
それが事実だ理由と、その種類の参照してください。

65
00:04:37.990 --> 00:04:41.806
Mその後、行列Xの1に等しく、この、

66
00:04:41.806 --> 00:04:48.325
それとDZなどの列に積み上げXMてX1

67
00:04:48.325 --> 00:04:56.040
転置そのようDZ（メートル）までDZ1されようとしています。

68
00:04:56.040 --> 00:05:00.900
あなたは何をこの行列時間を把握場合とそう、このベクトルはなるように動作し、

69
00:05:00.900 --> 00:05:05.585
m回×1分の1であることが判明しています

70
00:05:05.585 --> 00:05:12.523
DZ1プラス...プラスのXM DZM。

71
00:05:12.523 --> 00:05:21.405
だから、これは、n / 1ベクトルであり、これはあなたが実際に終わるものです

72
00:05:21.405 --> 00:05:24.725
DWとDWは、あなたが知っているこれらを取っていたので、

73
00:05:24.725 --> 00:05:27.710
XIのDZIし、それらを加算し、そのためには、まさにそれです

74
00:05:27.710 --> 00:05:32.300
この行列ベクトル乗算はとても再びやっとされ、

75
00:05:32.300 --> 00:05:35.655
1行のコードで、あなたはDWを計算することができます。

76
00:05:35.655 --> 00:05:40.010
だから、派生計算のベクトル化の実装は、単にこれです、

77
00:05:40.010 --> 00:05:44.540
あなたはデシベルと使用を実装するために、このラインを使用します

78
00:05:44.540 --> 00:05:50.540
この行は、DW実装し、トレーニングセット以上のすべての完全なループとのことに気づき

79
00:05:50.540 --> 00:05:55.265
あなたは今、あなたのパラメータにしたいアップデートを計算することができます。

80
00:05:55.265 --> 00:06:01.185
だから今、あなたが実際にロジスティック回帰を実装する方法を一緒にすべてを入れてみましょう。

81
00:06:01.185 --> 00:06:02.550
だから、これは、私たちのオリジナルです

82
00:06:02.550 --> 00:06:07.866
非常に非効率的な非ベクトル化の実装。

83
00:06:07.866 --> 00:06:11.775
だから、私たちは前のビデオでやった最初の事は右、このボリュームを取り除くでしたか？

84
00:06:11.775 --> 00:06:14.400
だから、代わりにDW1をループの、

85
00:06:14.400 --> 00:06:15.755
DW2というように、

86
00:06:15.755 --> 00:06:23.595
我々は、DW + = XIであるベクトル値DWでこれを交換しました

87
00:06:23.595 --> 00:06:28.775
これは今（I）DZベクトル倍です。

88
00:06:28.775 --> 00:06:32.000
しかし、今、我々はまた、ないを取り除くことができていることがわかります

89
00:06:32.000 --> 00:06:36.670
ただ、完全な行のループだけでなく、この完全なループを取り除きます。

90
00:06:36.670 --> 00:06:38.654
だから、ここであなたがそれを行う方法です。

91
00:06:38.654 --> 00:06:42.925
だから、私たちは前のスライドから持っているものを使用して、

92
00:06:42.925 --> 00:06:46.085
あなたは、capitalZを言うでしょう、

93
00:06:46.085 --> 00:06:57.625
ワット転置X + Bとコードあなたに等しいZは、資本ZはNPに等しい書き込みです。

94
00:06:57.625 --> 00:07:07.315
ワット転置X + B、その後の資本Zの等しいシグモイド

95
00:07:07.315 --> 00:07:12.710
だから、あなたは今、Iのすべての値について、こののこのすべて、すべてを計算しています

96
00:07:12.710 --> 00:07:14.715
前のスライドに続いて、

97
00:07:14.715 --> 00:07:21.070
私たちは、あなたがzが等しい計算すると述べた -  Y.

98
00:07:21.070 --> 00:07:24.460
だから、今あなたは私のすべての値のためにこのすべてを計算します。

99
00:07:24.460 --> 00:07:31.495
そして、最後にDWを1 / M Xに等しいです

100
00:07:31.495 --> 00:07:39.700
DZ転置とDBはあなたを知って、NPの1 / Mに等しいです。

101
00:07:39.700 --> 00:07:43.328
和DZ。

102
00:07:43.328 --> 00:07:49.120
だから、あなただけやったフロント伝播と逆伝播、

103
00:07:49.120 --> 00:07:53.030
本当に予測を計算し、上のデリバティブを計算します

104
00:07:53.030 --> 00:07:57.340
完全なループを使用せずに、すべてのMの訓練例。

105
00:07:57.340 --> 00:08:00.835
そして、その勾配降下の更新は、あなたがWを知っているだろう

106
00:08:00.835 --> 00:08:04.462
ワットマイナス学習率回も更新されます

107
00:08:04.462 --> 00:08:12.020
DW真上計算され、BはBマイナス学習率の倍のDBとして更新されました。

108
00:08:12.020 --> 00:08:17.341
時にはそれが割り当てであることに注意することが非常に近いです、

109
00:08:17.341 --> 00:08:21.675
しかし、私はその表記と完全に矛盾していないと思います。

110
00:08:21.675 --> 00:08:25.450
しかし、これで、あなただけ実装しています

111
00:08:25.450 --> 00:08:29.635
ロジスティック回帰の勾配降下の単一昇格。

112
00:08:29.635 --> 00:08:32.308
今、私は、我々は取り除くべきであると述べた知っています

113
00:08:32.308 --> 00:08:35.260
明示的な完全なループはいつでもあなたはしかし、あなたがしたいことができるかどうか

114
00:08:35.260 --> 00:08:38.230
など、複数のadjurationを実装

115
00:08:38.230 --> 00:08:42.880
勾配降下その後、あなたはまだ反復回数を完全にループを必要としています。

116
00:08:42.880 --> 00:08:47.860
それで、あなたは勾配降下の千回の審議を持つようにしたい場合は、

117
00:08:47.860 --> 00:08:53.675
あなたはまだ、反復回数を完全にループが必要になる場合があります。

118
00:08:53.675 --> 00:08:55.870
そのような最も外側の完全なループが、私はそれからあります

119
00:08:55.870 --> 00:08:59.210
その完全なループを取り除くためにどのような方法があるとは思いません。

120
00:08:59.210 --> 00:09:02.390
しかし、私はそれはあなたが実装できることを非常にクールだと思います

121
00:09:02.390 --> 00:09:07.117
完全なループを使用することを必要とせず、勾配降下の少なくとも一つの繰り返し。

122
00:09:07.117 --> 00:09:09.880
だから、それはあなたが今、非常にベクトル化する必要があり、それだと

123
00:09:09.880 --> 00:09:14.745
ロジスティック回帰の勾配降下の非常に効率的な実装。

124
00:09:14.745 --> 00:09:18.850
私は次のビデオで話したいことを一つだけに詳細がありますが、

125
00:09:18.850 --> 00:09:24.155
これは私が簡単に放送と呼ばれるこの技術に触れた、ここで私たちの説明です。

126
00:09:24.155 --> 00:09:28.240
放送は、Pythonの技法であることが判明し、

127
00:09:28.240 --> 00:09:32.915
numpyのは、あなたのコードの特定の部分もはるかに効率的にするために使用することができます。

128
00:09:32.915 --> 00:09:37.090
それでは、次のビデオでの放送の一部の詳細を見てみましょう。
