WEBVTT

1
00:00:00.000 --> 00:00:03.195
>>おかえりなさい。ベクトル化は基本的にあり

2
00:00:03.195 --> 00:00:07.315
あなたのコード内で明示的にフォルダを取り除くの芸術。

3
00:00:07.315 --> 00:00:11.835
実際には深い学習の深い学習時代の安全性には、

4
00:00:11.835 --> 00:00:15.210
あなたは、多くの場合、自分が比較的大規模なデータセットを上の訓練見つけます

5
00:00:15.210 --> 00:00:18.475
それだから、深い学習アルゴリズムは輝きする傾向があるとき。

6
00:00:18.475 --> 00:00:22.790
そうでない場合のでだから、それは非常に迅速にあなたのコードことが重要です、

7
00:00:22.790 --> 00:00:24.525
それは大きなデータセット上で実行している場合には、

8
00:00:24.525 --> 00:00:27.000
その後、あなただけ見つけ、あなたのコードが実行に時間がかかる場合があります

9
00:00:27.000 --> 00:00:30.255
自分は結果を得るために非常に長い時間を待っています。

10
00:00:30.255 --> 00:00:32.035
だから、深い学習の時代で、

11
00:00:32.035 --> 00:00:37.490
私はベクトル化を実行する能力が重要なスキルになっていると思います。

12
00:00:37.490 --> 00:00:40.010
のは、例を見てみましょう。

13
00:00:40.010 --> 00:00:42.225
だから、ベクトル化とは何でしょうか？

14
00:00:42.225 --> 00:00:48.780
ロジスティック回帰ではあなたは、ZはWの転置XプラスBに等しい計算する必要があります、

15
00:00:48.780 --> 00:00:55.405
Wは、この列ベクトルだったとXも、このベクトルです。

16
00:00:55.405 --> 00:00:58.000
あなたは、多くの機能を持っている場合は多分非常に大きなベクトルがあります。

17
00:00:58.000 --> 00:01:07.080
だから、WおよびXは、これらのRおよびRなし、NX次元ベクトルの両方でした。

18
00:01:07.080 --> 00:01:10.170
だから、W転置Xを計算するために、

19
00:01:10.170 --> 00:01:15.660
あなたは、非ベクトル化の実装を持っていた場合には、

20
00:01:15.660 --> 00:01:18.725
Zがゼロに等しいようにあなたが何かをするだろう。

21
00:01:18.725 --> 00:01:24.860
そして、私のためにXの範囲内

22
00:01:24.860 --> 00:01:27.330
だから、私のために1、2 NXは等しく、

23
00:01:27.330 --> 00:01:34.040
Zプラスは、W I回XIに等しいです。

24
00:01:34.040 --> 00:01:37.100
そして多分あなたは最後にZプラス等しいBを行います。

25
00:01:37.100 --> 00:01:39.855
だから、それは非ベクトル化の実装です。

26
00:01:39.855 --> 00:01:43.090
そして、あなたはそれが非常に遅くなるだろうことがわかります。

27
00:01:43.090 --> 00:01:48.560
これとは対照的に、ベクトル化実装は、単に直接W転置Xを計算します。

28
00:01:48.560 --> 00:01:52.085
Pythonやnumpyのは、

29
00:01:52.085 --> 00:02:01.428
あなたがそのために使用するコマンドでは、Zはnp.Wに等しいです

30
00:02:01.428 --> 00:02:06.270
Xは、これはWの転置Xを計算します

31
00:02:06.270 --> 00:02:09.075
そして、あなたはまた、ちょうどその直接にBを追加することができます。

32
00:02:09.075 --> 00:02:12.400
そして、あなたは、これははるかに高速であることがわかります。

33
00:02:12.400 --> 00:02:17.075
さんが実際に少しデモでこれを説明しましょう。

34
00:02:17.075 --> 00:02:21.960
だから、ここで私はいくつかのPythonコードを書くつもりだここで私の木星のノートブックです。

35
00:02:21.960 --> 00:02:28.041
だから、最初、私は輸入にnumpyのライブラリをインポートしてみましょう。

36
00:02:28.041 --> 00:02:30.000
P.を送信し、そう、例えば、

37
00:02:30.000 --> 00:02:36.570
次のように私は配列として作成することができます。

38
00:02:36.570 --> 00:02:39.560
さんが言ってみましょうプリントA.

39
00:02:39.560 --> 00:02:41.160
さて、このコードの塊を書きました、

40
00:02:41.160 --> 00:02:43.170
私はシフトが入るヒットした場合、

41
00:02:43.170 --> 00:02:44.847
それはコードを実行します。

42
00:02:44.847 --> 00:02:47.970
だから、それは、配列Aを作成し、それを出力します。

43
00:02:47.970 --> 00:02:50.580
それでは、ベクトル化のデモを行いましょう。

44
00:02:50.580 --> 00:02:51.990
私は、時間のライブラリをインポートするつもりです、

45
00:02:51.990 --> 00:02:53.580
我々はそれを使用するので、

46
00:02:53.580 --> 00:02:56.565
時間のために異なる操作が取るどのくらい。

47
00:02:56.565 --> 00:02:59.139
彼らは、配列Aを作成できますか？

48
00:02:59.139 --> 00:03:02.905
これらのランダムな思考ラウンド。

49
00:03:02.905 --> 00:03:10.065
これは、ランダムな値を持つ百万次元配列を作成します。

50
00:03:10.065 --> 00:03:13.300
B = np.random.rand。

51
00:03:13.300 --> 00:03:16.120
別の百万次元配列。

52
00:03:16.120 --> 00:03:20.810
そして、今、チック= time.timeが、これは、現在の時間を測定します

53
00:03:20.810 --> 00:03:26.395
C = np.dot（A、B）。

54
00:03:26.395 --> 00:03:28.649
TOC = time.time。

55
00:03:28.649 --> 00:03:31.950
そして、この印刷、

56
00:03:31.950 --> 00:03:34.857
それはベクトル化バージョンです。

57
00:03:34.857 --> 00:03:37.685
これは、ベクトル化バージョンです。

58
00:03:37.685 --> 00:03:41.985
そしてそう、のは、プリントアウトしてみましょう。

59
00:03:41.985 --> 00:03:45.060
のは、最後の時間を見てみましょう、

60
00:03:45.060 --> 00:03:48.330
チック×1000、 - ので、TOCがあります

61
00:03:48.330 --> 00:03:52.075
我々はミリ秒単位でこれを表現できるようにします。

62
00:03:52.075 --> 00:03:54.075
だから、MSはミリ秒です。

63
00:03:54.075 --> 00:03:56.435
私は、Shiftキーを入力してヒットするつもりです。

64
00:03:56.435 --> 00:04:01.890
だから、そのコードは、約3ミリ秒またはこの時間1.5を取りました

65
00:04:01.890 --> 00:04:06.170
一度に多分約1.5または3.5ミリ秒。

66
00:04:06.170 --> 00:04:08.370
私はそれを実行するように、それは少し異なり、

67
00:04:08.370 --> 00:04:12.085
多分、平均して、それは1.5ミリ秒のように取っているように見えます、

68
00:04:12.085 --> 00:04:15.665
多分2ミリ秒私はこれを実行すると。

69
00:04:15.665 --> 00:04:16.967
大丈夫。

70
00:04:16.967 --> 00:04:19.005
このコードブロックに追加し続けるのをしてみましょう。

71
00:04:19.005 --> 00:04:22.270
これは、非ベクトル化バージョンを実装していません。

72
00:04:22.270 --> 00:04:24.151
、見てみましょう、C = 0

73
00:04:24.151 --> 00:04:27.750
その後、チック= time.time。

74
00:04:27.750 --> 00:04:29.335
それでは、フォルダを実装してみましょう。

75
00:04:29.335 --> 00:04:35.348
100万の範囲内のIについては、

76
00:04:35.348 --> 00:04:38.676
私は右のゼロの数を選ぶでしょう。

77
00:04:38.676 --> 00:04:43.936
C + =（I）x（B、

78
00:04:43.936 --> 00:04:50.775
I）、その後、TOC = time.time。

79
00:04:50.775 --> 00:04:57.725
最後に、明示的な完全なループよりも印刷します。

80
00:04:57.725 --> 00:05:15.225
チック+「MS」 - それはかかる時間は、この1000×TOCあります

81
00:05:15.225 --> 00:05:17.505
我々はミリ秒単位でこれをやっていることを知っています。

82
00:05:17.505 --> 00:05:19.735
さんは、もう一つのことをやってみましょう。

83
00:05:19.735 --> 00:05:22.802
ちょうどCの我々の値をプリントアウトしてみましょう

84
00:05:22.802 --> 00:05:27.960
それは両方のケースで同じ値だことを確認するために、それを計算します。

85
00:05:27.960 --> 00:05:35.770
私はこれを実行して、それをチェックアウトする入力シフトを打つつもりです。

86
00:05:35.770 --> 00:05:38.305
どちらの場合も、ベクトル化バージョン

87
00:05:38.305 --> 00:05:41.125
非ベクトル化バージョンは、同じ値を計算し、

88
00:05:41.125 --> 00:05:45.355
あなたが知っているように、6.99から2.50、上のようにします。

89
00:05:45.355 --> 00:05:48.670
ベクトル化バージョンは、1.5ミリ秒を要しました。

90
00:05:48.670 --> 00:05:57.555
ループおよび非ベクトル化バージョンを明示的には、約400、約500ミリ秒を要しました。

91
00:05:57.555 --> 00:06:01.285
非ベクトル化バージョンは、300のようなものを取りました

92
00:06:01.285 --> 00:06:05.660
ベクトル化バージョンよりも長い時間。

93
00:06:05.660 --> 00:06:11.230
この例を使用すると、場合にのみ、あなたのコードをベクトル化することを忘れないことがわかり、

94
00:06:11.230 --> 00:06:15.120
あなたのコードは、実際には300倍以上速く動作します。

95
00:06:15.120 --> 00:06:16.540
ちょうどそれを再度実行してみましょう。

96
00:06:16.540 --> 00:06:18.930
ただ、それを再度実行します。

97
00:06:18.930 --> 00:06:22.235
うん。ベクトル化バージョン1.5ミリ秒、4つのループ。

98
00:06:22.235 --> 00:06:25.960
だから、481ミリ秒で、再び、

99
00:06:25.960 --> 00:06:29.535
明示的な4つのループを行うには約300倍遅く。

100
00:06:29.535 --> 00:06:30.980
エンジンxが遅くなる場合は、

101
00:06:30.980 --> 00:06:33.880
それはあなたのコード間の差は多分1分を取っています

102
00:06:33.880 --> 00:06:37.615
実行するように言って5時間を取っ対実行します。

103
00:06:37.615 --> 00:06:41.410
そして、あなたは深い学習アルゴリズムを実装しているとき、

104
00:06:41.410 --> 00:06:43.300
あなたは本当に戻って速く結果を得ることができます。

105
00:06:43.300 --> 00:06:46.590
あなたのコードをベクトル場合、それははるかに高速になります。

106
00:06:46.590 --> 00:06:49.300
あなたのいくつかは聞いたことがあるかもしれない多くの

107
00:06:49.300 --> 00:06:54.260
スケーラブルな深い学習の実装は、GPUやグラフィックス処理ユニット上で実行されます。

108
00:06:54.260 --> 00:06:59.515
しかし、すべてのデモは、私が実際にCPUに木星のノートブックに今やりました。

109
00:06:59.515 --> 00:07:04.530
そしてそれは、GPUとCPUの両方が並列命令を持っていることが判明しました。

110
00:07:04.530 --> 00:07:07.530
彼らは時々SIMD命令を呼ばれています。

111
00:07:07.530 --> 00:07:11.190
これは、単一命令複数データの略です。

112
00:07:11.190 --> 00:07:13.045
しかし、これは基本的に意味するもので、

113
00:07:13.045 --> 00:07:16.835
あなたは、このような組み込み関数を使用する場合

114
00:07:16.835 --> 00:07:23.495
np.functionまたは明示的にループのために実装する必要はありませんその他の機能。

115
00:07:23.495 --> 00:07:28.150
それは取るにPhytonパイを可能にします

116
00:07:28.150 --> 00:07:33.640
並列処理のはるかに優れた利点は、はるかに速く、あなたの計算を行います。

117
00:07:33.640 --> 00:07:38.610
そして、これはGPUの上のCPUと計算上の両方の計算事実です。

118
00:07:38.610 --> 00:07:41.070
これは、GPUがで非常に優れているだけのことです

119
00:07:41.070 --> 00:07:44.980
これらのSIMD演算が、CPUはその時にも、実際にはそれほど悪くはありません。

120
00:07:44.980 --> 00:07:47.510
GPUとしてたぶん同じように良いではありません。

121
00:07:47.510 --> 00:07:51.660
あなたは、ベクトル化が大幅にあなたのコードをスピードアップすることができますどのように見ています。

122
00:07:51.660 --> 00:07:54.685
覚えておくべき経験則では、いつでも可能です

123
00:07:54.685 --> 00:07:57.425
明示的な4つのループを使用しないでください。

124
00:07:57.425 --> 00:07:59.980
のは、いくつかのより多くの例を見て次の動画へ行こう

125
00:07:59.980 --> 00:08:04.000
また、ベクトル化とは、ロジスティック回帰をベクトル化し始めます。
