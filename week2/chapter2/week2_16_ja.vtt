WEBVTT

1
00:00:00.450 --> 00:00:04.786
あなたをできるようにするのpythonの能力
放送操作を使用すると、

2
00:00:04.786 --> 00:00:09.944
より一般的には、の大きな柔軟性
Pythonのnumpyのプログラム言語です、

3
00:00:09.944 --> 00:00:14.748
私は、両方の強さを考えるだけでなく、
プログラミング言語の弱点。

4
00:00:14.748 --> 00:00:18.393
私は、彼らので、それが強さだと思います
言語の表現力を作成します。

5
00:00:18.393 --> 00:00:22.547
言語の大きな柔軟性をすることができます
あなたは、多くは1つだけでも、成し遂げます

6
00:00:22.547 --> 00:00:24.165
コードの行。

7
00:00:24.165 --> 00:00:28.530
であるためしかし、弱点もあります
放送とこの偉大な量の

8
00：00：28.530  - > 00：00：32.610
柔軟性、時にはそれが可能です
あなたは非常に微妙なバグを導入することができますか

9
00:00:32.610 --> 00:00:36.530
あなたがいないのであれば非常に奇妙な、バグを探して
の複雑さのすべてに精通

10
00：00：36.530  - > 00：00：39.800
どの放送と
どのように放送作品のようにしています。

11
00:00:39.800 --> 00:00:44.500
たとえば、列ベクトルを取る場合
あなたは、行ベクトルにそれを考え追加します

12
00:00:44.500 --> 00:00:48.700
それは次元を投げることを期待
不一致またはタイプエラーか何か。

13
00:00:48.700 --> 00:00:52.620
しかし、あなたが実際に戻って得るかもしれません
行ベクトルの和としてマトリックスと

14
00:00:52.620 --> 00:00:54.030
列ベクトル。

15
00:00:54.030 --> 00:00:58.370
だから、内部のロジックがあります
パイソンのこれらの奇妙な効果。

16
00:00:58.370 --> 00:01:03.370
しかし、あなたは、Pythonに慣れていない場合は、
私は、一部の学生は非常に奇妙持って見てきました

17
00:01:03.370 --> 00:01:05.680
バグを見つけるのは非常に難しいです。

18
00:01:05.680 --> 00:01:09.380
だから私はこのビデオで何をしたいです
いくつかのカップルのヒントをあなたと共有し、

19
00:01:09.380 --> 00:01:12.800
以下のために非常に有用であったトリック
私は、排除しますか、

20
00:01:12.800 --> 00:01:17.320
すべての奇妙を簡素化し、排除
私自身のコード内のバグを探しています。

21
00:01:17.320 --> 00:01:19.280
そして、私は願ってこれらのヒントとし、
トリック、

22
00:01:19.280 --> 00:01:24.193
あなたもはるかに容易にできるようになります
バグのない、Pythonとnumpyのコードを記述します。

23
00:01:25.430 --> 00:01:30.200
以下のいずれかの操作を説明するために、
Pythonの-numpyのの直感的な影響、

24
00:01:30.200 --> 00:01:34.990
特にあなたがベクターを構築する方法
python-numpyのは、私は迅速なデモを行いましょう。

25
00:01:34.990 --> 00:01:40.817
、のは、（5）= np.random.randnを設定してみましょう

26
00:01:40.817 --> 00:01:45.699
これは5つのランダムガウスを作成します

27
00:01:45.699 --> 00:01:49.640
配列aに格納された変数。

28
00:01:49.640 --> 00:01:55.420
そしてそうしましょうプリント（a）と
今ではことが判明します

29
00:01:55.420 --> 00:02:02.740
形状、あなたがこれを行います
この5つのカラー構造です。

30
00:02:02.740 --> 00:02:06.320
そして、これはランクと呼ばれています
Pythonで1つのアレイと

31
00:02:06.320 --> 00:02:09.750
それは、行ベクトルでもないのですでも
列ベクトル。

32
00:02:09.750 --> 00:02:12.570
そして、これはいくつかを持って、それをリード
やや非直観的な効果。

33
00:02:12.570 --> 00:02:17.180
ですから、例えば、私は転置を印刷する場合、
それは同じを見てしまいます。

34
00:02:17.180 --> 00:02:20.220
だから、および
転置は同じを見て終わります。

35
00:02:20.220 --> 00:02:25.800
そして、私は間の内積を印刷する場合
あなたが考えるかもしれない転置、

36
00:02:25.800 --> 00:02:30.190
回転置多分外であります
製品は、あなたが多分行列与える必要があります。

37
00:02:30.190 --> 00:02:34.170
しかし、私はそれを行う場合には、
あなたの代わりに番号を取り戻します。

38
00:02:34.170 --> 00:02:39.612
だから私はお勧めだろうかということです
新しいネットワークをコーディングしているとき、

39
00:02:39.612 --> 00:02:46.115
あなただけのデータ構造を使用しないこと
形状5、またはN、ランク1つの配列です。

40
00:02:46.115 --> 00:02:52.134
代わりに、あなたはこの、（5,1）に設定した場合、

41
00:02:52.134 --> 00:02:58.764
これはにコミット
（5,1）の列ベクトルです。

42
00:02:58.764 --> 00:03:02.399
そして一方で以前、および
転置は、同じに見えました

43
00:03:02.399 --> 00:03:06.590
それが今転置なり、
今転置行ベクトルです。

44
00:03:06.590 --> 00:03:08.437
1つの微妙な違いに注意してください。

45
00:03:08.437 --> 00:03:12.213
このデータ構造では、2つあります
角括弧は、我々は転置を印刷するとき。

46
00:03:12.213 --> 00:03:14.460
以前のに対し、
1つの平方ブラケットがありました。

47
00:03:14.460 --> 00:03:19.393
だから、違います
これは本当に1によってある間

48
00:03:19.393 --> 00:03:23.481
の対5行列
これらは、1つのアレイをランク付けします。

49
00:03:23.481 --> 00:03:28.129
そして、あなたが印刷する場合は、言います
転置との積、

50
00:03:28.129 --> 00:03:32.444
これはあなたの外側を与えます
ベクトルの積、右？

51
00:03:32.444 --> 00:03:35.795
だから、の外積
ベクターは、あなたの行列を与えます。

52
00:03:35.795 --> 00:03:40.305
それでは、詳細に見てみましょう
私たちはここで見たもので。

53
00:03:40.305 --> 00:03:43.185
私たちが走った最初のコマンド、
ちょうど今、これをしました。

54
00:03:43.185 --> 00:03:47.839
そして、これはとのデータ構造を作成しました

55
00:03:47.839 --> 00:03:52.930
a.shapeので（5）この面白いものでした

56
00:03:52.930 --> 00:03:57.270
これは、ランク1の配列と呼ばれています。

57
00:03:57.270 --> 00:03:58.960
そして、これは非常に面白いデータ構造です。

58
00:03:58.960 --> 00:04:04.000
これは、どちらかと一貫して動作しません。
行ベクトルや列ベクトル、

59
00:04:04.000 --> 00:04:06.750
これはそのいくつかを作ります
非直観的効果。

60
00:04:06.750 --> 00:04:10.770
それでは、私がお勧めするつもりはということです
あなたのプログラミングをやっているとき

61
00:04:10.770 --> 00:04:14.050
演習、またはあなたがしているという事実で
ロジスティック回帰を実装しますか、

62
00:04:14.050 --> 00:04:19.740
それだけであなたのニューラルネットワーク
これらランク1つの配列を使用しないでください。

63
00:04:21.020 --> 00:04:24.098
その代わり、毎回場合
あなたは配列を作成し、

64
00:04:24.098 --> 00:04:27.500
あなたはそれを作ることにコミット
いずれかの列ベクトルなので、

65
00:04:27.500 --> 00:04:32.360
これは、（5,1）ベクトルを作成し、又は
その行ベクトル化にコミット

66
00:04:32.360 --> 00:04:36.670
その後、あなたのベクトルの行動
理解しやすいかもしれません。

67
00:04:36.670 --> 00:04:43.115
したがって、この場合、
a.shapeは5,1に等しいことになるだろう。

68
00:04:43.115 --> 00:04:48.510
そして、これはよく似て動作しますが、
実際には、これは列ベクトルです。

69
00:04:48.510 --> 00:04:53.233
そして、それはあなたがと考えることができる理由です
それは列ベクトルです（5,1）行列、。

70
00:04:53.233 --> 00:04:56.880
そしてここでa.shapeは、1,5になるだろう

71
00:04:56.880 --> 00:05:01.000
これは一貫して動作します
行ベクトルとして。

72
00:05:02.150 --> 00:05:06.258
ですから、ベクトルを必要とするとき、
私はこのまたはこれを言うのいずれかを使用しますが、

73
00:05:06.258 --> 00:05:07.538
ないランク1の配列。

74
00:05:07.538 --> 00:05:12.061
私は私の中で多くのことを行うもう一つ
私が何を完全にわからない場合はコードがあります

75
00:05:12.061 --> 00:05:17.029
私のベクトルのうちの1つの次元、
私は、多くの場合、アサーション文でスローされます

76
00:05:17.029 --> 00:05:21.720
このように、この場合には、確認するために、
これは、（5,1）ベクトルです。

77
00:05:21.720 --> 00:05:23.730
だから、これは列ベクトルです。

78
00:05:23.730 --> 00:05:26.900
これらの表明は、実際にあります
実行するように設定し、

79
00:05:26.900 --> 00:05:30.250
彼らはまた、として機能するのに役立ち
あなたのコードのドキュメント。

80
00:05:30.250 --> 00:05:34.160
だから、アサーションでスローすることを躊躇しません
このたびのようなステートメント

81
00:05:34.160 --> 00:05:35.320
のように感じる。

82
00:05:35.320 --> 00:05:39.510
そして最後に、いくつかの理由であれば
あなたは、ランク1の配列で終わるん

83
00:05:39.510 --> 00:05:43.960
あなたはこれを再構築することができ、a.reshapeに等しいです。

84
00:05:43.960 --> 00:05:48.900
（5,1）の配列またはその（1,5）の配列を言うに

85
00:05:48.900 --> 00:05:53.750
それは、より一貫として動作すること
列ベクトル又は行ベクトルのいずれか。

86
00:05:53.750 --> 00:05:57.626
だから私は時々、学生を見てきました
追跡することが非常に困難になってしまいます

87
00:05:57.626 --> 00:06:01.119
これらは非直観的であるため、
ランク1つの配列の影響。

88
00:06:01.119 --> 00:06:06.246
私の昔にランク1つの配列を除去することにより、
コードは、私は私のコードをシンプルになったと思います。

89
00:06:06.246 --> 00:06:09.463
そして、私は実際にそれを見つけることができませんでした
私ができる事の面で制限

90
00:06:09.463 --> 00:06:10.335
コード内で発現します。

91
00:06:10.335 --> 00:06:12.469
私は、ランク1つの配列を使用することはありません。

92
00:06:12.469 --> 00:06:17.090
そしてそう持ち帰りを簡素化するためにあります
あなたのコードは、ランク1つの配列を使用しないでください。

93
00:06:17.090 --> 00:06:19.437
常に1つの行列でのnのいずれかを使用して、

94
00:06:19.437 --> 00:06:24.510
基本的には列ベクトル、またはずつ
N行列、又は基本的に行ベクトル。

95
00:06:24.510 --> 00:06:26.599
の多くをトスして自由に感じます
その挿入文、

96
00:06:26.599 --> 00:06:29.590
寸法をダブルチェック
あなたの行列と配列の。

97
00:06:29.590 --> 00:06:34.480
そしてまた、呼び出しについて恥ずかしがらないでください
ことを確認するために、操作を再形成あなた

98
00:06:34.480 --> 00:06:38.780
マトリックスまたはあなたのベクトル
あなたはそれをする必要が次元があります。

99
00:06:38.780 --> 00:06:39.420
そのため、

100
00:06:39.420 --> 00:06:44.770
私は願って提案のセット
あなたは、バグの原因を排除することができます

101
00:06:44.770 --> 00:06:48.840
Pythonコードから、問題になります
あなたが完了しやすい行使する。
