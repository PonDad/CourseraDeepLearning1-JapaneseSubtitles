WEBVTT

1
00:00:00.676 --> 00:00:04.870
前のビデオでは、いくつかのを見ました
どのようにベクトル化の例は、

2
00:00:04.870 --> 00:00:08.140
組み込み関数使用し、
明示的に回避することによって、

3
00:00:08.140 --> 00:00:11.210
ループは、あなたが高速化することができます
大幅にあなたのコードアップ。

4
00:00:11.210 --> 00:00:12.870
さらにいくつかの例を見てみましょう。

5
00:00:13.960 --> 00:00:17.898
心に留めておくために親指のルールは、ときです
あなたの新しいネットワークをプログラミングする、またはしています

6
00:00:17.898 --> 00:00:20.061
あなただけの回帰をプログラミングしているとき、

7
00:00:20.061 --> 00:00:22.341
可能な限り避けます
明示的なforループ。

8
00:00:22.341 --> 00:00:27.337
そして、それは決してすることは常に可能ではありません
forループ使用しますが、ときにすることができ

9
00:00:27.337 --> 00:00:32.580
内蔵機能を使用するか、いくつかを見つけます
何が必要計算する他の方法は、

10
00:00:32.580 --> 00:00:37.120
あなたは、多くの場合であればより速く行きますよ
あなたは、明示的なforループを持っています。

11
00:00:37.120 --> 00:00:38.640
別の例を見てみましょう。

12
00:00:38.640 --> 00:00:45.227
あなたは、ベクトルを計算したい場合は、これまで
U行列Aとの積として、

13
00:00:45.227 --> 00:00:50.757
そして、別のベクトルv、
その後、私たちの行列の定義

14
00:00:50.757 --> 00:00:56.659
乗算あなたのUIがあるということです
J ,, Aijを、Vjの上和に等しいです。

15
00:00:56.659 --> 00:00:58.406
それはあなたがUIを定義する方法です。

16
00:00:58.406 --> 00:01:03.851
など
これの非ベクトル化の実装

17
00:01:03.851 --> 00:01:09.750
uはNP.zerosに等しい設定することです、
それが1でn個になります。

18
00:01:09.750 --> 00:01:12.280
私のために、というように。

19
00:01:12.280 --> 00:01:15.600
jについて、など。..

20
00:01:16.670 --> 00:01:23.050
そして、U [i]はプラスイコール
[I] [J]回V [J]。

21
00:01:23.050 --> 00:01:26.971
だから今、この2つのforループがあり、
iとjの両方をループ。

22
00:01:26.971 --> 00:01:30.864
だから、それは、非ベクトル化バージョンです

23
00:01:30.864 --> 00:01:37.467
ベクトル化実装され
uはNPドット（A、V）に等しいと言うことです。

24
00:01:37.467 --> 00:01:40.726
そして、右側の実装、
ベクトル化バージョン、

25
00:01:40.726 --> 00:01:45.040
今、forループ二つの異なる排除
道より高速になるだろう。

26
00:01:45.040 --> 00:01:46.790
さんは、もう一つの例で見ていきましょう。

27
00:01:46.790 --> 00:01:50.720
あなたは既にベクトルを持っているとしましょう、
V、メモリ内のあなた

28
00:01:50.720 --> 00:01:55.420
指数演算を適用したいです
このベクトルvのすべての要素に。

29
00:01:55.420 --> 00:02:00.370
だから、uは、ベクトルに等しい置くことができ、
それは、V1に電子です、

30
00:02:00.370 --> 00:02:05.700
V2に電子、というように、
VNにeまでダウン。

31
00:02:05.700 --> 00:02:09.390
だから、これは次のようになります
非ベクトル化の実装、

32
00:02:09.390 --> 00:02:13.342
これは、あなたが初期化最初にあります
ゼロのベクトルにU。

33
00:02:13.342 --> 00:02:18.350
そして、あなたはforループを持っています
一度要素の1を計算します。

34
00:02:18.350 --> 00:02:23.890
しかし、それはPythonとnumpyのことが判明します
許可多くの組み込み関数を持っています

35
00:02:23.890 --> 00:02:31.270
あなただけで、これらのベクトルを計算します
単一の関数への単一の呼び出し。

36
00:02:31.270 --> 00:02:34.720
だから、私はどうなるのか
これはインポートされ実装

37
00:02:36.500 --> 00:02:41.640
NPとしてnumpyの、次に何を

38
00:02:41.640 --> 00:02:47.250
ちょうど（V）U = np.exp呼び出します。

39
00:02:47.250 --> 00:02:52.029
だから、一方以前に、以下のことを注意してください
あなたは、明示的なforループすることを持っていました、

40
00:02:52.029 --> 00:02:56.879
ここでのコードは1行だけで、ちょうどV
出力ベクトルとして入力ベクトルuとして、

41
00:02:56.879 --> 00:03:01.438
あなたは明示的に脱却しました
、および実装上のforループ

42
00:03:01.438 --> 00:03:06.030
the right will be much faster that
明示的なforループを必要とする1。

43
00:03:06.030 --> 00:03:10.360
実際には、numpyのライブラリは、多くを持っています
ベクトル値関数の。

44
00:03:10.360 --> 00:03:16.124
（v）を計算しますのでnp.log
要素ごとのログ、

45
00:03:16.124 --> 00:03:20.260
np.absは、絶対値を計算します

46
00:03:20.260 --> 00:03:25.525
np.maximumを計算
要素ごとの最大

47
00:03:25.525 --> 00:03:30.207
すべてのの最大を取ります
0とVの要素。

48
00:03:30.207 --> 00:03:36.230
V ** 2だけワイズ要素取ります
Vの各要素の二乗。

49
00:03:36.230 --> 00:03:42.950
V以上の一つは、要素毎の逆数をとり、
等々。

50
00:03:42.950 --> 00:03:47.390
だから、あなたが書くように誘惑されるたびに
forループを見て、とありますかどうかを確認

51
00:03:47.390 --> 00:03:52.022
numpyの組み込み関数を呼び出す方法
そのため、ループせずにそれを行うには。

52
00:03:53.200 --> 00:03:55.387
それでは、これらの教訓の全てを見てみましょうし、

53
00:03:55.387 --> 00:03:59.036
私たちのlogisti回帰に適用します
勾配降下実装、

54
00:03:59.036 --> 00:04:03.240
そして私たちは、少なくとも取り除くことができるかどうかを確認
2 forループの一つで、私たちは持っていました。

55
00:04:03.240 --> 00:04:04.310
だからここに私たちのコードです

56
00:04:04.310 --> 00:04:09.350
ロジスティック用誘導体を計算します
回帰、そして我々は、forループ2を持っていました。

57
00:04:09.350 --> 00:04:12.430
一つは、ここにこの1アップで、
もう一つは、この1でした。

58
00:04:12.430 --> 00:04:15.736
だから、私たちの例では、我々は、nxは2に等しいあったが、

59
00:04:15.736 --> 00:04:20.406
あなたはより多くの機能を持っていた場合
ちょうど2の特徴あなたがしたいです

60
00:04:20.406 --> 00:04:25.194
DW1の上にforループを持っている必要があります、
DW2、DW3、というように。

61
00:04:25.194 --> 00:04:31.397
だから、その実際にはありますかのように
図4Jは、図1、図2、及びXに等しいです。

62
00:04:31.397 --> 00:04:37.490
dWj更新されます。

63
00:04:37.490 --> 00:04:41.850
だから我々は排除したいのですが
forループこの第二。

64
00:04:41.850 --> 00:04:43.940
それは我々がこのスライドにやるものです。

65
00:04:43.940 --> 00:04:49.214
だから、方法は、私たちはそうしますよ
であることの代わりに、明示的に

66
00:04:49.214 --> 00:04:54.120
、DW1、DW2を初期化し、その上ゼロに

67
00:04:54.120 --> 00:05:00.267
私たちはこれを取り除くためになるだろうと
代わりにベクトルDW作ります。

68
00:05:00.267 --> 00:05:04.884
だから我々はDWがnp.zerosに等しい設定しようとしています、
そして

69
00:05:04.884 --> 00:05:10.000
さんは1で、このNXにしましょう、
次元ベクトル。

70
00:05:11.020 --> 00:05:14.527
次に、ここでは、これに代えてのために

71
00:05:14.527 --> 00:05:18.663
個々のコンポーネントをループ、

72
00:05:18.663 --> 00:05:23.551
私たちは、これを使用します
ベクトル値演算、

73
00:05:23.551 --> 00:05:27.080
DWプラスXI回DZ（I）に等しいです。

74
00:05:27.080 --> 00:05:33.017
そして最後に、これに代えて、

75
00:05:33.017 --> 00:05:39.160
私達はちょうどDW格差がmに等しい必要があります。

76
00:05:39.160 --> 00:05:42.540
だから今、私たちは2を持っていることから行ってきました
forループちょうど1 forループへ。

77
00:05:42.540 --> 00:05:47.270
我々はまだforループループ、このいずれかを持っています
個々の訓練例を超えます。

78
00:05:49.180 --> 00:05:52.190
だから私はこのビデオはあなたを与えた願っています
ベクトル化の感覚。

79
00:05:52.190 --> 00:05:56.442
そして、forループ1を取り除くことにより、
あなたのコードは、すでに高速に実行されます。

80
00:05:56.442 --> 00:05:58.370
しかし、それは私たちもやれることが判明しました。

81
00:05:58.370 --> 00:06:02.432
だから、次のビデオは、方法についてお話します
でもロジスティック侵略をベクトル化します

82
00:06:02.432 --> 00:06:03.420
さらに。

83
00:06:03.420 --> 00:06:07.430
そして、あなたはかなり驚くべき結果を参照してください、
そのいずれかのforループを使用せずに、

84
00:06:07.430 --> 00:06:10.890
forループを必要とせず
訓練例以上、

85
00:06:10.890 --> 00:06:14.850
あなたは、プロセスにコードを書くことができ
全体のトレーニングセット。

86
00:06:14.850 --> 00:06:17.170
だから、ほとんどすべて同時に。

87
00:06:17.170 --> 00:06:18.880
それでは、次のビデオでそれを見てみましょう。
