WEBVTT

1
00:00:00.060 --> 00:00:03.750
どのようにあなたが見た前のビデオで

2
00:00:01.890 --> 00:00:05.819
導関数を計算し、実装

3
00:00:03.750 --> 00:00:07.500
ちょうどに関して勾配降下

4
00:00:05.819 --> 00:00:09.929
宗教的に1つのトレーニング例

5
00:00:07.500 --> 00:00:12.450
回帰今はエマのためにそれをやってみたいです

6
00:00:09.929 --> 00:00:14.429
始めるために訓練例は、してみましょう

7
00:00:12.450 --> 00:00:17.460
の定義という自分自身を思い出させます

8
00:00:14.429 --> 00:00:19.380
コスト関数Jのコスト関数WP

9
00:00:17.460 --> 00:00:22.699
この平均は、あなたが気にあり

10
00:00:19.380 --> 00:00:25.350
右1 Iからm個の合計を超えるMに1に等しいです。

11
00:00:22.699 --> 00:00:29.519
あなたが損失を知っているとき、あなたのアルゴリズム

12
00:00:25.350 --> 00:00:33.510
出力例で私たちはあなたをしている理由

13
00:00:29.519 --> 00:00:36.120
AIがIきた上の予測である知っています

14
00:00:33.510 --> 00:00:40.620
Z Iのシグマで訓練された例

15
00:00:36.120 --> 00:00:46.800
W転置Xのシグマに等しいです

16
00:00:40.620 --> 00:00:48.510
私たちが示してどのようなので、[OK]をプラスB

17
00:00:46.800 --> 00:00:51.600
前のスライドには、任意の単一のためであります

18
00:00:48.510 --> 00:00:55.620
例を訓練LDを計算する方法

19
00:00:51.600 --> 00:01:00.180
デリバティブあなただけのものを持っています

20
00:00:55.620 --> 00:01:03.809
W1 D W2ので、D偉大な訓練例と

21
00:01:00.180 --> 00:01:06.689
私は今に上付き文字をd

22
00:01:03.809 --> 00:01:08.369
あなたが得る対応する値を示します

23
00:01:06.689 --> 00:01:10.799
あなたは私たちが上で何をしたか行っている場合

24
00:01:08.369 --> 00:01:15.030
前のスライドが、一つだけを使用して

25
00:01:10.799 --> 00:01:17.850
私はそれを使用していた訓練例X I Y I

26
00:01:15.030 --> 00:01:20.759
あなたは今、どちらかだけでなくそうにありません

27
00:01:17.850 --> 00:01:22.530
合計が、全体的なコスト関数に気づきます

28
00:01:20.759 --> 00:01:26.220
本当に1理由は平均でした

29
00:01:22.530 --> 00:01:29.369
その個々の損失のm個の期間にわたって

30
00:01:26.220 --> 00:01:32.810
それは、デリバティブに関することが判明します

31
00:01:29.369 --> 00:01:38.600
全体的なコスト関数のW1を避けます

32
00:01:32.810 --> 00:01:42.600
また、平均になるだろう

33
00:01:38.600 --> 00:01:46.170
誘導体は、W1に対して

34
00:01:42.600 --> 00:01:48.240
個々の損失の観点から、私たち以前に

35
00:01:46.170 --> 00:01:54.119
すでにこれを計算する方法を示しています

36
00:01:48.240 --> 00:01:55.890
私は右た私たちあなたと言うD W1と用語

37
00:01:54.119 --> 00:01:57.659
前のスライド・ショーにノウハウ

38
00:01:55.890 --> 00:02:00.450
単一のトレーニング例上のコンピュータ

39
00:01:57.659 --> 00:02:03.119
あなたは何をする必要があるか本当に計算されます

40
00:02:00.450 --> 00:02:04.680
私たちが示したように、これらの独自のデリバティブ

41
00:02:03.119 --> 00:02:07.350
前のトレーニングの例と

42
00:02:04.680 --> 00:02:10.379
それらを平均化し、これはあなたを与えるだろう

43
00:02:07.350 --> 00:02:10.830
あなたが使用することができ、全体的な勾配

44
00:02:10.379 --> 00:02:12.870
インプリメント

45
00:02:10.830 --> 00:02:15.390
まっすぐな香りの中に私はいた知っています

46
00:02:12.870 --> 00:02:17.730
詳細の多くが、のは、すべてを見てみましょう

47
00:02:15.390 --> 00:02:19.920
このアップやコンクリートにこれを包みます

48
00:02:17.730 --> 00:02:21.690
アルゴリズムと何を実装する必要があります

49
00:02:19.920 --> 00:02:24.960
と一緒にロジスティック回帰

50
00:02:21.690 --> 00:02:28.350
これだけ何を働い勾配降下

51
00:02:24.960 --> 00:02:37.770
あなたは、Jが0に等しいのが初期化させないことができます

52
00:02:28.350 --> 00:02:40.140
DW 1に0dBの等号に等しいDW 2 0に等しいです

53
00:02:37.770 --> 00:02:43.190
0と私たちがやろうとしていることは、使用aは

54
00:02:40.140 --> 00:02:45.690
トレーニングセットをループのためにと

55
00:02:43.190 --> 00:02:47.670
それぞれを尊重する導関数を計算

56
00:02:45.690 --> 00:02:49.020
例を訓練して、それらを追加

57
00:02:47.670 --> 00:02:51.480
すべての権利私たちは、私のためにそれを行うと見

58
00:02:49.020 --> 00:02:54.360
Mが数であるので、Mを介して1に等しいです

59
00:02:51.480 --> 00:02:57.090
我々はCIがWに等しい計算訓練例

60
00:02:54.360 --> 00:03:00.360
X IプラスBを転置武装

61
00:02:57.090 --> 00:03:04.020
予測AIは、ZIのシグマに等しいです。

62
00:03:00.360 --> 00:03:09.120
その後、あなたは知っているのだが、J jをアップ追加してみましょうしましょう

63
00:03:04.020 --> 00:03:12.360
プラス、私はI Mプラス1つのマイナスを切望Y等しいです

64
00:03:09.120 --> 00:03:14.010
私は1マイナスAIを記録し、その後に置くY

65
00:03:12.360 --> 00:03:15.959
全体の前に負の符号

66
00:03:14.010 --> 00:03:20.580
我々は先に見たようなものとし、我々は持っています

67
00:03:15.959 --> 00:03:28.500
DのZIか、AIマイナスのy Iに等しく、

68
00:03:20.580 --> 00:03:33.180
DWを取得プラスX1 I dのZI BはW2に等しいプラス

69
00:03:28.500 --> 00:03:35.280
X i2とさd ZIと等しいか、と私はこれをやっています

70
00:03:33.180 --> 00:03:37.680
あなただけ持っていると仮定して計算

71
00:03:35.280 --> 00:03:41.070
nが2に等しくなるように、2つの機能であります

72
00:03:37.680 --> 00:03:45.480
そうでなければ、TW 3 w2はD W1のzのためにこれを行います

73
00:03:41.070 --> 00:03:47.430
などとGBプラスV V IおよびIに等しいです

74
00:03:45.480 --> 00:03:49.350
それは、forループの終わりだと思うと、

75
00:03:47.430 --> 00:03:51.900
そして、最終的にはすべてのMのためにこれをやりました

76
00:03:49.350 --> 00:03:54.959
それでもにする必要があります訓練例

77
00:03:51.900 --> 00:03:56.880
私たちが計算しているので、Mで割ます

78
00:03:54.959 --> 00:04:01.920
平均するので、D W1

79
00:03:56.880 --> 00:04:04.260
私は、コールがDBをm個の分割するM DWに等しい場合

80
00:04:01.920 --> 00:04:07.019
デバイスはすべて、完全にMに等しいです

81
00:04:04.260 --> 00:04:09.060
これらのすべてと平均値など

82
00:04:07.019 --> 00:04:11.160
計算あなただけ計算しました

83
00:04:09.060 --> 00:04:14.250
コスト関数の導関数Jと

84
00:04:11.160 --> 00:04:17.010
1 W 2 W 3つのパラメータをEに対する

85
00:04:14.250 --> 00:04:22.079
そして、Bのコメントは、私たちがしている何の詳細ので、

86
00:04:17.010 --> 00:04:25.020
我々はDW 1 + DWとDPを使用していること

87
00:04:22.079 --> 00:04:28.169
 - 右後のようにアキュムレータとして

88
00:04:25.020 --> 00:04:31.500
あなたはDW 1知っている、この計算は同じです

89
00:04:28.169 --> 00:04:33.509
あなたの全体的なコストの誘導体

90
00:04:31.500 --> 00:04:36.780
W 1に対する機能及び

91
00:04:33.509 --> 00:04:39.720
同様にDW 2とDVのためのように気づきます

92
00:04:36.780 --> 00:04:41.520
DW 1 + DW上付きIを持っていないために

93
00:04:39.720 --> 00:04:43.379
我々は、このコードでそれらを使用しているので、

94
00:04:41.520 --> 00:04:45.690
全体にわたって合計するアキュムレータ

95
00:04:43.379 --> 00:04:48.960
コントラストbziに一方トレーニングセット

96
00:04:45.690 --> 00:04:51.539
ここでこれはに関してP Zにありました

97
00:04:48.960 --> 00:04:53.490
あるだけで1つの学習事例

98
00:04:51.539 --> 00:04:55.740
その理由は、私が参照するために上付き文字を持っています

99
00:04:53.490 --> 00:04:58.379
どちらかそれだ1つのトレーニング例

100
00:04:55.740 --> 00:05:00.960
上のコンピュータおよびそのすべて終えました

101
00:04:58.379 --> 00:05:03.449
これらの計算は、一歩を実装します

102
00:05:00.960 --> 00:05:06.360
勾配降下のあなたはW1を実装します

103
00:05:03.449 --> 00:05:10.710
学習率 -  W1として更新されます

104
00:05:06.360 --> 00:05:13.740
1はW2倍d個のW1 W2はアップデートを提供します

105
00:05:10.710 --> 00:05:17.190
学習率の時間D W2とBが与えられます

106
00:05:13.740 --> 00:05:21.000
Bとして更新 - 学習率の倍EB

107
00:05:17.190 --> 00:05:23.879
PW 1 DW 2 + DBあなたに知ってどこどこ

108
00:05:21.000 --> 00:05:27.000
また、最終的にはJここしまう計算と

109
00:05:23.879 --> 00:05:28.590
あなたの費用のための正しい値であること

110
00:05:27.000 --> 00:05:31.050
スライド上の機能ので、すべてのもの

111
00:05:28.590 --> 00:05:33.060
のちょうど1つのステップを実装

112
00:05:31.050 --> 00:05:35.699
勾配降下ので、あなたがする必要があります

113
00:05:33.060 --> 00:05:37.680
このスライド複数の上のすべてを繰り返し

114
00:05:35.699 --> 00:05:40.469
の複数のステップを取るために時間

115
00:05:37.680 --> 00:05:41.819
これらの詳細場合、勾配降下

116
00:05:40.469 --> 00:05:43.830
あまりにも複雑に見えます

117
00:05:41.819 --> 00:05:45.960
再びそれについてあまり心配しないでください

118
00:05:43.830 --> 00:05:48.599
今、うまくいけば、このすべてが鮮明になります

119
00:05:45.960 --> 00:05:50.520
ときに行くとDでこれを実装します

120
00:05:48.599 --> 00:05:54.120
プログラミングの割り当てが、それは結局のところ

121
00:05:50.520 --> 00:05:57.300
2つの弱点があります

122
00:05:54.120 --> 00:05:59.729
実施と同様のように計算

123
00:05:57.300 --> 00:06:01.440
実装することである付着

124
00:05:59.729 --> 00:06:03.960
ロジスティック回帰あなたがする必要がある。この方法

125
00:06:01.440 --> 00:06:05.490
ループの最初のループのための2つを書きます

126
00:06:03.960 --> 00:06:07.770
Mの訓練の上に小さなループです

127
00:06:05.490 --> 00:06:10.919
実施例および第2のforループであります

128
00:06:07.770 --> 00:06:13.139
こっちにすべての機能をループのために

129
00:06:10.919 --> 00:06:15.930
右この例のように、我々は2つだけを持っていました

130
00:06:13.139 --> 00:06:17.879
機能nが2であり、Xに等しい2になるように

131
00:06:15.930 --> 00:06:21.000
あなたはより多くの機能を持っている場合は2に等しいが、

132
00:06:17.879 --> 00:06:23.099
あなたはDW 1 DW 2を書き​​終わると、

133
00:06:21.000 --> 00:06:25.979
あなたはDW vについて同様の計算を持っています

134
00:06:23.099 --> 00:06:29.009
ようにDWまでのnだからのように思えます

135
00:06:25.979 --> 00:06:31.279
以上のループのために持っている必要があります

136
00:06:29.009 --> 00:06:33.199
n個すべての機能を超える機能

137
00:06:31.279 --> 00:06:36.049
あなたは深い学習を実施しているとき

138
00:06:33.199 --> 00:06:38.419
あなたが持つ明示的なことを見つけるアルゴリズム

139
00:06:36.049 --> 00:06:41.839
あなたのコード内のループのためのあなたを作ります

140
00:06:38.419 --> 00:06:44.149
このアルゴリズムは、あまり効率を実行し、そうで

141
00:06:41.839 --> 00:06:46.669
深い学習誤差はに移動します

142
00:06:44.149 --> 00:06:48.649
どんどん大きくデータセットとそうであること

143
00:06:46.669 --> 00:06:50.779
あなたのアルゴリズムを実装することができ

144
00:06:48.649 --> 00:06:52.969
ループの明示的な使用せずです

145
00:06:50.779 --> 00:06:55.129
本当に重要とするのに役立ちます

146
00:06:52.969 --> 00:06:56.719
それそんなに大きなデータセットのスケール

147
00:06:55.129 --> 00:06:58.129
のが設定されていることが判明

148
00:06:56.719 --> 00:07:01.159
ベクトル化と呼ばれる技術

149
00:06:58.129 --> 00:07:03.559
あなたが取り除くことを可能にする技術

150
00:07:01.159 --> 00:07:06.169
あなたのコードIにおけるこれらの明示的な完全なループ

151
00:07:03.559 --> 00:07:08.199
前深い学習時代に考えます

152
00:07:06.169 --> 00:07:11.239
それは深い学習の台頭の前です

153
00:07:08.199 --> 00:07:13.159
ベクトル化はあなたを持ってよかったです

154
00:07:11.239 --> 00:07:15.589
時には、車両の速度を上げるためにそれを行うことができ

155
00:07:13.159 --> 00:07:17.749
そして時にはないが、深いですで

156
00:07:15.589 --> 00:07:20.029
ある学習時代のベクトル化

157
00:07:17.749 --> 00:07:22.699
このようなforループを取り除くと

158
00:07:20.029 --> 00:07:25.039
このように非常に重要になってきました

159
00:07:22.699 --> 00:07:26.989
私たちは、より多くのトレーニングをしているので、

160
00:07:25.039 --> 00:07:29.239
非常に大規模なデータセットとそうあなたは本当に

161
00:07:26.989 --> 00:07:31.209
ので、非常に効率的であるためにあなたのコードが必要です

162
00:07:29.239 --> 00:07:34.219
次のいくつかの動画では、我々は話よ

163
00:07:31.209 --> 00:07:37.339
どのようにすべてを実装するベクトル化し、

164
00:07:34.219 --> 00:07:40.879
この1つでもフルを使用せず

165
00:07:37.339 --> 00:07:43.069
ループ私はあなたが意味を持っている願っています。このように、

166
00:07:40.879 --> 00:07:44.299
ロジスティック回帰を暗示する方法の

167
00:07:43.069 --> 00:07:46.339
ロジスティックまたは勾配降下

168
00:07:44.299 --> 00:07:47.959
物事の回帰が鮮明になります

169
00:07:46.339 --> 00:07:50.299
あなたは、プログラムの演習を実施したときに

170
00:07:47.959 --> 00:07:51.829
しかし、前には、実際にプログラムを実行します

171
00:07:50.299 --> 00:07:54.079
程度の運動ましょう最初の話

172
00:07:51.829 --> 00:07:56.419
ベクトルその後、あなたが実装することができるように

173
00:07:54.079 --> 00:07:58.369
この全体のことは、単一の実装します

174
00:07:56.419 --> 00:08:01.479
勾配降下の反復なし

175
00:07:58.369 --> 00:08:01.479
任意の秋のニュースを使用して
