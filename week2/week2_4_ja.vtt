WEBVTT

1
00:00:00.590 --> 00:00:03.210
あなたは、ロジスティック回帰モデルを見てきました。

2
00:00:03.210 --> 00:00:06.560
あなたは、その損失関数を見てきました
あなたがやっているどれだけの対策

3
00:00:06.560 --> 00:00:08.780
単一のトレーニング例。

4
00:00:08.780 --> 00:00:13.530
また、そのコスト関数を見てきました
対策方法もごパラメータワットと

5
00:00:13.530 --> 00:00:16.590
Bは、あなたの全体のトレーニングセット上で行っています。

6
00:00:16.590 --> 00:00:21.600
さて、あなたはどのように使用できるかについて話しましょう
勾配降下アルゴリズムは、訓練します

7
00:00:21.600 --> 00:00:25.730
または学ぶために、パラメータワットと
あなたのトレーニングセットにB。

8
00:00:25.730 --> 00:00:30.030
要約すると、ここに精通しています
ロジスティック回帰アルゴリズム。

9
00:00:31.130 --> 00:00:34.700
そして、我々は、第二の上に持っています
ラインコスト関数、J、

10
00:00:34.700 --> 00:00:37.879
これの関数であり、
あなたのパラメータW aとb。

11
00:00:37.879 --> 00:00:39.960
そして、それは、平均として定義されています。

12
00:00:39.960 --> 00:00:44.140
だから、1メートルを超える時間の合計です
この損失関数の。

13
00:00:44.140 --> 00:00:48.470
そして、その損失関数
対策方法もごアルゴリズム

14
00:00:48.470 --> 00:00:53.170
のそれぞれに出力Yハット（I）
訓練例アップスタックまたは

15
00:00:53.170 --> 00:00:58.000
地上真のラベルyに比較して（I）
トレーニング例のそれぞれに。

16
00:00:58.000 --> 00:01:00.886
そして、完全な式があります
右に出て拡大しました。

17
00:01:00.886 --> 00:01:04.130
だから、コスト関数策
どれだけあなたのパラメータワットと

18
00:01:04.130 --> 00:01:06.760
Bは、トレーニングセットに行っています。

19
00:01:06.760 --> 00:01:11.510
だから、パラメータのセットを学ぶために
ワットと、私たちがしたいことを自然に感じbは

20
00:01:11.510 --> 00:01:17.930
コストを行い、W aとbを見つけます
関数J（W b）はできるだけ小さいです。

21
00:01:17.930 --> 00:01:21.320
そこでここではイラストです
勾配降下の。

22
00:01:21.320 --> 00:01:25.320
この図では
横軸は表し

23
00:01:25.320 --> 00:01:28.510
あなたの空間パラメータ、W aとb。

24
00:01:28.510 --> 00:01:32.350
実際には、wははるかに高くなることができます
次元が、目的のため

25
00:01:32.350 --> 00:01:38.190
プロット、のは、シングルとしてwを示してみましょう
単一の実数として、実数aとb。

26
00:01:38.190 --> 00:01:40.770
コスト関数J（W、B、）であり、

27
00:01:40.770 --> 00:01:45.130
これらの上記その後、いくつかの表面
横軸W及びB。

28
00:01:45.130 --> 00:01:50.720
だから、表面の高さを表しています
ある時点で（B、W）Jの値。

29
00:01:50.720 --> 00:01:55.070
そして、私たちがやりたいことは実際にあります
Wの値を見つけるためにと

30
00:01:55.070 --> 00:01:59.730
最小値に対応するB
コスト関数J.の

31
00:02:00.830 --> 00:02:06.050
これは、このコストことが判明します
機能Jは凸関数です。

32
00:02:06.050 --> 00:02:10.327
だから、ただ一つの大きなボウルです、
これは凸関数であり、

33
00:02:10.327 --> 00:02:13.717
これは、関数に反対しています
それは次のようになり、

34
00:02:13.717 --> 00:02:18.120
非凸であると
別の地元の多くを持っています。

35
00:02:18.120 --> 00:02:22.240
事実だから、私たちのコスト
関数J定義されるように（B、W）

36
00:02:22.240 --> 00:02:27.020
ここでの凸は、巨大な理由の一つです
なぜ我々は、この特定のコスト関数を使用し、

37
00:02:27.020 --> 00:02:29.610
ロジスティック回帰のためJ、。

38
00:02:29.610 --> 00:02:33.810
だから、良い値を見つけるために
パラメータ、

39
00:02:33.810 --> 00:02:39.160
私たちがやることはワット初期化され、
いくつかの初期値をB、

40
00:02:39.160 --> 00:02:43.360
多分その小さな赤い点で示されます。

41
00:02:43.360 --> 00:02:47.562
そして、ロジスティック回帰のためのほとんど
任意の初期化メソッドは、作品

42
00:02:47.562 --> 00:02:50.690
通常、あなたはゼロに値を初期化します。

43
00:02:50.690 --> 00:02:52.910
ランダムな初期化も動作しますが、

44
00:02:52.910 --> 00:02:55.630
人々は通常のためにそれをしません
ロジスティック回帰。

45
00:02:55.630 --> 00:02:59.310
しかし、この関数は凸状であるため、
あなたは初期化にかかわらず、

46
00:02:59.310 --> 00:03:02.180
あなたは、同じポイントに到達する必要がありますか
ほぼ同じポイント。

47
00:03:02.180 --> 00:03:06.450
そして、何勾配降下することはされません
それは最初の時点で始まり、

48
00:03:06.450 --> 00:03:10.310
その後のステップを取ります
最も急な下り坂方向。

49
00:03:10.310 --> 00:03:15.290
だから、勾配降下の1つのステップの後
あなたがいるので、そこに終わるかもしれません

50
00:03:15.290 --> 00:03:19.320
で下り坂のステップを取るしようとしています
最急降下の方向または

51
00:03:19.320 --> 00:03:21.250
早く下り坂できるだけ。

52
00:03:21.250 --> 00:03:23.600
だから、一回の反復です
勾配降下の。

53
00:03:23.600 --> 00:03:27.084
そして、勾配の2回の反復後
あなたがそこにステップかもしれません降下、

54
00:03:27.084 --> 00:03:28.830
3回の繰り返しのように。

55
00:03:28.830 --> 00:03:32.640
私は、これは今の裏に隠れていると思います
うまくいけば、最終的になるまでのプロット、あなた

56
00:03:32.640 --> 00:03:38.880
このグローバル最適に収束かを取得
大域的最適に近いもの。

57
00:03:38.880 --> 00:03:42.300
したがって、この絵は示して
勾配降下アルゴリズム。

58
00:03:42.300 --> 00:03:44.310
のは、細部のもう少し書いてみましょう。

59
00:03:44.310 --> 00:03:47.750
説明のために、してみましょう
いくつかの機能があることを言って、J（w）は、

60
00:03:47.750 --> 00:03:51.700
あなたは最小限にしたいこと、および
多分その関数は次のようになります。

61
00:03:51.700 --> 00:03:54.650
描画するこれを簡単にするために、
私はのために、Bを無視するつもりです

62
00:03:54.650 --> 00:03:59.210
今、ちょうどこの一次元作ります
代わりに、高次元プロットのプロット。

63
00:03:59.210 --> 00:04:01.240
だから、勾配降下は、これを行い、

64
00:04:01.240 --> 00:04:06.740
私たちは、繰り返し実行するつもりです
次の更新アウト。

65
00:04:06.740 --> 00:04:09.467
Wの値を取るつもりだったと
それを更新し、

66
00:04:09.467 --> 00:04:12.508
大腸等号を使用する予定
ワットを更新表現します。

67
00:04:12.508 --> 00:04:17.426
だから、ワットマイナスアルファ、倍にwを設定し、

68
00:04:17.426 --> 00:04:22.200
これは、誘導体DJ（W）/ DWです。

69
00:04:22.200 --> 00:04:26.230
私は繰り返し、それを行います
アルゴリズムが収束するまで。

70
00:04:26.230 --> 00:04:30.666
だから、表記のポイントのカップル、
アルファここで、学習率であり、

71
00:04:30.666 --> 00:04:36.820
コントロール我々が取るどのように大きなステップ
各反復または勾配降下。

72
00:04:36.820 --> 00:04:41.200
我々はによっていくつかの方法については後で話しましょう
学習率アルファを選択します。

73
00:04:41.200 --> 00:04:44.490
そして第二に、この量は、ここでは、
これは誘導体です。

74
00:04:44.490 --> 00:04:48.010
これは基本的に更新または変更です
あなたはワットパラメータにしたいです。

75
00:04:48.010 --> 00:04:52.700
私たちは、コードへの書き込みを開始するとき
勾配降下を実装し、

76
00:04:52.700 --> 00:04:57.380
私たちは、規則を使用するつもりです
その私たちのコード内の変数名

77
00:04:58.620 --> 00:05:02.300
DW表すために使用されます
この微分項。

78
00:05:02.300 --> 00:05:06.551
だから、コードを書くとき
あなたのような何かを書きます

79
00:05:06.551 --> 00:05:10.046
WコロンはDWワットマイナスアルファ倍に等しいです。

80
00:05:10.046 --> 00:05:14.750
そして、私たちは可変とするDWを使用します
この微分項を表現するために名前を付けます。

81
00:05:14.750 --> 00:05:19.330
今度は、ちょうどこのことを確認してみましょう
勾配降下更新が理にかなっています。

82
00:05:19.330 --> 00:05:21.880
のは、そのwはこっちだったとしましょう。

83
00:05:21.880 --> 00:05:26.060
ですから、この点にいます
コスト関数J（W）。

84
00:05:26.060 --> 00:05:29.270
定義ことを忘れないでください
誘導体

85
00:05:29.270 --> 00:05:31.420
点での関数の勾配です。

86
00:05:31.420 --> 00:05:36.190
だから、関数の傾きは本当にあります
右、幅で割った高さ、

87
00:05:36.190 --> 00:05:40.290
ここでは、この時の低い三角形の
その時点でJ（W）への接線。

88
00:05:40.290 --> 00:05:43.900
だから、ここで誘導体は正です。

89
00:05:43.900 --> 00:05:48.830
Wは、Wマイナス学習として更新されます
派生倍の割合。

90
00:05:48.830 --> 00:05:53.310
誘導体は、正とそうです
そう、ワットから引いてしまいます

91
00:05:53.310 --> 00:05:55.260
あなたは左にステップを撮って終了します。

92
00:05:55.260 --> 00:05:59.380
そしてそう勾配降下はなります
ゆっくりと自分のアルゴリズムを作ります

93
00:05:59.380 --> 00:06:04.450
あなたが持っている場合は、パラメータを減らします
ワットのこの大きな値で始まりました。

94
00:06:04.450 --> 00:06:08.545
別の例として、ここで終わったwがあれば、

95
00:06:08.545 --> 00:06:15.050
ここでは、この時点での傾き
DJの/ DWが負になることとそうなります

96
00:06:15.050 --> 00:06:22.771
勾配降下更新します
アルファ倍の負の数を引きます。

97
00:06:22.771 --> 00:06:27.122
だから、ゆっくりwが増加してしまいます
あなたは大きなwを作ってしまうと、

98
00:06:27.122 --> 00:06:31.530
連続する反復と大きく、
勾配降下。

99
00:06:31.530 --> 00:06:34.387
だからうまくいけばどうか
左側に初期化しますか、

100
00:06:34.387 --> 00:06:39.000
右勾配降下に移動します
ここでは、このグローバルな最小値に向けます。

101
00:06:39.000 --> 00:06:43.100
あなたは誘導体に慣れていない場合、または
微積分とし、

102
00:06:43.100 --> 00:06:49.710
何この用語DJ（W）/ DW手段、
それについてはあまり心配しないでください。

103
00:06:49.710 --> 00:06:53.770
私たちは、についていくつか詳しく説明します
次のビデオではデリバティブ。

104
00:06:53.770 --> 00:06:56.761
あなたは微積分の深い知識を持っている場合は、

105
00:06:56.761 --> 00:07:02.321
あなたはより深いを持つことができるかもしれません
どのようにニューラルネットワークの仕事についての直観。

106
00:07:02.321 --> 00:07:05.471
しかし、あなたはそれがない方にも
微積分精通し、

107
00:07:05.471 --> 00:07:10.091
次のいくつかのビデオで私たちはあなたを与えるだろう
デリバティブについての十分な直感と

108
00:07:10.091 --> 00:07:14.980
あなたができるようになります微積分について
効果的にニューラルネットワークを使用します。

109
00:07:14.980 --> 00:07:16.410
しかし、全体的な直観のための

110
00:07:16.410 --> 00:07:21.520
今、この言葉が表すということです
関数の傾き、および

111
00:07:21.520 --> 00:07:26.760
我々は、関数の傾きを知りたいです
パラメータの現在の設定で

112
00:07:26.760 --> 00:07:31.140
我々は、これらの措置をとることができるように
最急降下、私たちは何を知っているので、

113
00:07:31.140 --> 00:07:35.450
行くためにでステップする方向
コスト関数J.上の下り坂

114
00:07:36.660 --> 00:07:42.520
だから私たちは私たちの勾配降下を書きました
J（S）のみwはあなたのパラメータだった場合。

115
00:07:42.520 --> 00:07:47.150
ロジスティック回帰では、あなたの費用
関数は、WとBの両方の関数です。

116
00:07:47.150 --> 00:07:50.894
のような場合では、内部ループので、
勾配降下、それはここではこの事で、

117
00:07:50.894 --> 00:07:53.302
あなたが持っているこの事
次のように繰り返しになります。

118
00:07:53.302 --> 00:07:57.970
あなたはワットとしてwを更新して終了します
マイナス学習率倍

119
00:07:57.970 --> 00:08:02.030
WへJ（W、B）に関しての誘導体。

120
00:08:02.030 --> 00:08:07.460
そして、あなたはBマイナスとしてBを更新します
学習率倍

121
00:08:07.460 --> 00:08:12.270
コストの派生
Bに関してで機能。

122
00:08:12.270 --> 00:08:17.300
だから、一番下にあるこれら二つの式は、
あなたが実装実際の更新です。

123
00:08:17.300 --> 00:08:22.320
さておき、私は1つだけ言及したいと思います
微積分で表記大会います

124
00:08:22.320 --> 00:08:24.560
何人かの人々に少し混乱するかもしれません。

125
00:08:24.560 --> 00:08:28.387
私はそれが超重要だとは思いません
あなたが微積分を理解しているが、

126
00:08:28.387 --> 00:08:32.411
あなたがこれを見る場合には、私は確認します
あなたはこれをあまり考えていないということ。

127
00:08:32.411 --> 00:08:35.519
これは、ここで計算では、この用語ということで、

128
00:08:35.519 --> 00:08:40.730
私たちは、実際に休閑として記述し、
その面白いの波線記号の。

129
00:08:40.730 --> 00:08:46.160
したがって、このシンボル、
これは実際には小文字のdです

130
00:08:46.160 --> 00:08:51.070
ファンシーフォントで、ために定型化されたフォントで
あなたはこの式を見ると、このすべて

131
00:08:51.070 --> 00:08:56.145
これは[聞こえない] J（B、W）ではない、または手段
関数の実際の傾き

132
00:08:56.145 --> 00:09:01.580
J（W、B）、どのくらいその機能
W方向に傾斜しています。

133
00:09:01.580 --> 00:09:06.640
そして、微積分における表記のルール、
これは私が思うには、完全に論理的ではありません

134
00:09:06.640 --> 00:09:11.780
しかし、計算のための表記でのルール、
これは私はあまり物事を作ると思います

135
00:09:11.780 --> 00:09:16.940
あなたがする必要以上に複雑
Jは、2つ以上の関数である場合ということです

136
00:09:16.940 --> 00:09:21.550
より多くの変数は、代わりの使用
小文字のDあなたはこの変な記号を使用しています。

137
00:09:21.550 --> 00:09:24.380
これは、部分的に呼び出され
派生記号。

138
00:09:24.380 --> 00:09:26.120
しかし、このことを心配しないでください、

139
00:09:26.120 --> 00:09:31.090
そしてJは、一つだけの機能があれば
変数、その後は小文字のDを使用しています。

140
00:09:31.090 --> 00:09:33.960
唯一の違いので、
あなたはこの面白いを使用するかどうか

141
00:09:33.960 --> 00:09:38.040
偏微分記号または
私たちが上に行ったように小文字のD、

142
00:09:38.040 --> 00:09:41.570
Jは、2つの関数であるかどうかであります
複数の変数。

143
00:09:41.570 --> 00:09:45.900
その場合、あなたはこのシンボルを使用し、
偏微分記号、または

144
00:09:45.900 --> 00:09:51.480
Jは、1のみの関数である場合
変数は、あなたは下ケースdを使用します。

145
00:09:51.480 --> 00:09:55.410
これは、これらの変なルールの一つであります
その計算における表記の

146
00:09:55.410 --> 00:09:58.540
私は物事をより作ると思います
彼らは必要以上に複雑。

147
00:09:58.540 --> 00:10:03.300
しかし、あなたは、この偏微分を見れば
シンボル、それは意味のすべては、あなたが測定しているあります

148
00:10:03.300 --> 00:10:07.290
関数の傾き、
変数の一つに関して。

149
00:10:07.290 --> 00:10:12.530
そして、同様に付着します
数学以前は正しいです

150
00:10:12.530 --> 00:10:18.070
こちらの微積分で表記、
Jは、2つの入力だけではなく、いずれかを持っています。

151
00:10:18.070 --> 00:10:22.540
一番下にこの事は書かれるべき
この偏微分シンプルで。

152
00:10:22.540 --> 00:10:28.290
しかし、それは実際と同じことを意味し、
小文字のdとほぼ同じもの。

153
00:10:28.290 --> 00:10:31.360
最後に、あなたがコードでこれを実装する場合、

154
00:10:31.360 --> 00:10:36.220
私たちは、その規則を使用するつもりです
この量、によって本当に量

155
00:10:36.220 --> 00:10:41.980
あなたはとして表します、wを更新します
あなたのコード内の変数DW。

156
00:10:41.980 --> 00:10:44.220
そしてこの量、右？

157
00:10:44.220 --> 00:10:47.230
あなたはBを更新したいれる量

158
00:10:47.230 --> 00:10:50.740
変数で表します
あなたのコードでデシベル。

159
00:10:50.740 --> 00:10:55.580
すべての権利、そう、それはどのようにあなたです
勾配降下を実装することができます。

160
00:10:55.580 --> 00:10:59.830
今、あなたはいくつかのための計算を見ていない場合
年は、私はそれはのように見えるかもしれませんことを知っています

161
00:10:59.830 --> 00:11:03.770
より計算で多くのデリバティブ
あなたは、これまでと快適かもしれません。

162
00:11:03.770 --> 00:11:06.330
しかし、あなたがそのように感じているならば、
それについて心配しないでください。

163
00:11:06.330 --> 00:11:10.150
次のビデオでは、私たちはあなたを与えるだろう
デリバティブについてよりよく直感。

164
00:11:10.150 --> 00:11:13.560
とにも深い数学なし
微積分の理解、

165
00:11:13.560 --> 00:11:16.310
ただ直感的で
微積分の理解

166
00:11:16.310 --> 00:11:19.130
あなたは、神経を作ることができるようになります
ネットワークが有効に働きます。

167
00:11:19.130 --> 00:11:22.743
そのそれでは、次のビデオに行きましょう
どこ我々はについて少し詳しく説明します

168
00:11:22.743 --> 00:11:23.470
デリバティブ。
